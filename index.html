<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Dark City Taxi Drift</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
<link rel="icon" href="data:,">
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #020308;
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    display: block;
    background: radial-gradient(circle at top, #151824 0%, #05060b 45%, #020308 100%);
  }

  #joystickContainer, #driftButton {
    position: fixed;
    z-index: 10;
    touch-action: none;
  }

  #joystickContainer {
    left: 10px;
    bottom: 10px;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: 2px solid #444;
    background: rgba(0,0,0,0.4);
    display: none; /* shown via JS if mobile */
  }
  #joystick {
    position: absolute;
    left: 50%;
    top: 50%;
    width: 60px;
    height: 60px;
    margin-left: -30px;
    margin-top: -30px;
    border-radius: 50%;
    background: rgba(200,200,200,0.25);
    box-shadow: 0 0 10px rgba(0,0,0,0.8);
  }

  #driftButton {
    right: 10px;
    bottom: 30px;
    width: 90px;
    height: 90px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(255,230,0,0.35), rgba(80,60,0,0.9));
    border: 2px solid #c9a800;
    color: #fff;
    font-weight: bold;
    font-family: sans-serif;
    display: none; /* shown via JS if mobile */
    align-items: center;
    justify-content: center;
    text-shadow: 0 0 6px #000;
    box-shadow: 0 0 18px rgba(0,0,0,0.9);
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="joystickContainer">
  <div id="joystick"></div>
</div>
<div id="driftButton">DRIFT</div>

<script>
(function() {
  const canvas = document.getElementById('game');
  const gl = canvas.getContext('webgl', { antialias: true }) || canvas.getContext('experimental-webgl');
  if (!gl) {
    alert('WebGL not supported');
    return;
  }

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
  window.addEventListener('resize', resize);
  resize();

  // Mobile detection
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const joystickContainer = document.getElementById('joystickContainer');
  const joystick = document.getElementById('joystick');
  const driftButton = document.getElementById('driftButton');
  if (isMobile) {
    joystickContainer.style.display = 'block';
    driftButton.style.display = 'flex';
  }

  // Shaders (dark, lit city)
  const vsSource = `
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec3 aColor;
    uniform mat4 uProjection;
    uniform mat4 uView;
    uniform mat4 uModel;
    uniform vec3 uLightDir;
    uniform vec3 uAmbient;
    varying vec3 vColor;
    void main(void) {
      vec3 worldNormal = normalize(mat3(uModel) * aNormal);
      float diff = max(dot(-uLightDir, worldNormal), 0.0);
      float rim = pow(1.0 - max(dot(worldNormal, vec3(0.0,1.0,0.0)), 0.0), 2.0) * 0.3;
      vec3 lit = aColor * (uAmbient + diff * 0.9) + rim * vec3(0.2,0.2,0.25);
      vColor = lit;
      gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.0);
    }
  `;
  const fsSource = `
    precision mediump float;
    varying vec3 vColor;
    void main(void) {
      gl_FragColor = vec4(vColor, 1.0);
    }
  `;

  function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vs = compileShader(gl.VERTEX_SHADER, vsSource);
  const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);

  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
  }
  gl.useProgram(program);

  const aPosition = gl.getAttribLocation(program, 'aPosition');
  const aNormal = gl.getAttribLocation(program, 'aNormal');
  const aColor = gl.getAttribLocation(program, 'aColor');
  const uProjection = gl.getUniformLocation(program, 'uProjection');
  const uView = gl.getUniformLocation(program, 'uView');
  const uModel = gl.getUniformLocation(program, 'uModel');
  const uLightDir = gl.getUniformLocation(program, 'uLightDir');
  const uAmbient = gl.getUniformLocation(program, 'uAmbient');

  // Matrices
  function identity() {
    const out = new Float32Array(16);
    out[0] = out[5] = out[10] = out[15] = 1;
    return out;
  }
  function translate(m, v) {
    const [x, y, z] = v;
    const out = m.slice(0);
    out[12] = m[0] * x + m[4] * y + m[8] * z + m[12];
    out[13] = m[1] * x + m[5] * y + m[9] * z + m[13];
    out[14] = m[2] * x + m[6] * y + m[10] * z + m[14];
    out[15] = m[3] * x + m[7] * y + m[11] * z + m[15];
    return out;
  }
  function scale(m, v) {
    const [x, y, z] = v;
    const out = m.slice(0);
    out[0] *= x; out[1] *= x; out[2] *= x; out[3] *= x;
    out[4] *= y; out[5] *= y; out[6] *= y; out[7] *= y;
    out[8] *= z; out[9] *= z; out[10] *= z; out[11] *= z;
    return out;
  }
  function rotateY(m, rad) {
    const c = Math.cos(rad);
    const s = Math.sin(rad);
    const out = new Float32Array(16);
    out[0] = m[0] * c + m[8] * s;
    out[1] = m[1] * c + m[9] * s;
    out[2] = m[2] * c + m[10] * s;
    out[3] = m[3] * c + m[11] * s;
    out[8] = m[0] * -s + m[8] * c;
    out[9] = m[1] * -s + m[9] * c;
    out[10] = m[2] * -s + m[10] * c;
    out[11] = m[3] * -s + m[11] * c;
    out[4] = m[4];
    out[5] = m[5];
    out[6] = m[6];
    out[7] = m[7];
    out[12] = m[12];
    out[13] = m[13];
    out[14] = m[14];
    out[15] = m[15];
    return out;
  }
  function perspective(fovy, aspect, near, far) {
    const f = 1.0 / Math.tan(fovy / 2);
    const nf = 1 / (near - far);
    const out = new Float32Array(16);
    out[0] = f / aspect;
    out[5] = f;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[14] = (2 * far * near) * nf;
    return out;
  }
  function lookAt(eye, center, up) {
    const [ex, ey, ez] = eye;
    const [cx, cy, cz] = center;
    const [ux, uy, uz] = up;

    let zx = ex - cx, zy = ey - cy, zz = ez - cz;
    let len = Math.hypot(zx, zy, zz);
    zx /= len; zy /= len; zz /= len;

    let xx = uy * zz - uz * zy;
    let xy = uz * zx - ux * zz;
    let xz = ux * zy - uy * zx;
    len = Math.hypot(xx, xy, xz);
    xx /= len; xy /= len; xz /= len;

    let yx = zy * xz - zz * xy;
    let yy = zz * xx - zx * xz;
    let yz = zx * xy - zy * xx;
    len = Math.hypot(yx, yy, yz);
    yx /= len; yy /= len; yz /= len;

    const out = new Float32Array(16);
    out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
    out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
    out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
    out[12] = -(xx * ex + xy * ey + xz * ez);
    out[13] = -(yx * ex + yy * ey + yz * ez);
    out[14] = -(zx * ex + zy * ey + zz * ez);
    out[15] = 1;
    return out;
  }

  // Cube with normals
  function createCube(size, color) {
    const s = size / 2;
    const [r, g, b] = color;
    const positions = [];
    const normals = [];
    const colors = [];

    function face(nx, ny, nz, verts) {
      for (let i = 0; i < 6; i++) {
        normals.push(nx, ny, nz);
        colors.push(r, g, b);
      }
      positions.push(...verts);
    }

    // Front
    face(0, 0, 1, [
      -s, -s,  s,  s, -s,  s,  s,  s,  s,
      -s, -s,  s,  s,  s,  s, -s,  s,  s
    ]);
    // Back
    face(0, 0, -1, [
       s, -s, -s, -s, -s, -s, -s,  s, -s,
       s, -s, -s, -s,  s, -s,  s,  s, -s
    ]);
    // Left
    face(-1, 0, 0, [
      -s, -s, -s, -s, -s,  s, -s,  s,  s,
      -s, -s, -s, -s,  s,  s, -s,  s, -s
    ]);
    // Right
    face(1, 0, 0, [
       s, -s,  s,  s, -s, -s,  s,  s, -s,
       s, -s,  s,  s,  s, -s,  s,  s,  s
    ]);
    // Top
    face(0, 1, 0, [
      -s,  s,  s,  s,  s,  s,  s,  s, -s,
      -s,  s,  s,  s,  s, -s, -s,  s, -s
    ]);
    // Bottom
    face(0, -1, 0, [
      -s, -s, -s,  s, -s, -s,  s, -s,  s,
      -s, -s, -s,  s, -s,  s, -s, -s,  s
    ]);

    return {
      positions: new Float32Array(positions),
      normals: new Float32Array(normals),
      colors: new Float32Array(colors)
    };
  }

  const taxiCube = createCube(1, [0.95, 0.85, 0.1]);
  const buildingCube = createCube(1, [0.08, 0.12, 0.2]);
  const windowCube = createCube(1, [0.2, 0.4, 0.8]);
  const groundCube = createCube(1, [0.03, 0.03, 0.05]);

  const positionBuffer = gl.createBuffer();
  const normalBuffer = gl.createBuffer();
  const colorBuffer = gl.createBuffer();

  function drawCube(cube, modelMatrix) {
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, cube.positions, gl.STATIC_DRAW);
    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aPosition);

    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, cube.normals, gl.STATIC_DRAW);
    gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aNormal);

    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, cube.colors, gl.STATIC_DRAW);
    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aColor);

    gl.uniformMatrix4fv(uModel, false, modelMatrix);
    gl.drawArrays(gl.TRIANGLES, 0, cube.positions.length / 3);
  }

  // Dark skyscraper city
  const buildings = [];
  for (let i = 0; i < 90; i++) {
    const ring = 40 + Math.random() * 120;
    const angle = Math.random() * Math.PI * 2;
    const x = Math.cos(angle) * ring;
    const z = Math.sin(angle) * ring;
    const h = 25 + Math.random() * 55;
    buildings.push({ x, z, h });
  }

  // Taxi physics (medium weight, but responsive)
  let taxi = {
    x: 0,
    y: 0.5,
    z: 0,
    heading: 0,
    vx: 0,
    vz: 0
  };

  const keys = {};
  window.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if ([' ', 'w', 'a', 's', 'd'].includes(e.key.toLowerCase())) e.preventDefault();
  });
  window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  // Mobile joystick + drift
  let joyActive = false;
  let joyCenter = { x: 0, y: 0 };
  let joyVector = { x: 0, y: 0 };
  let driftTouch = false;

  function joyStart(e) {
    e.preventDefault();
    joyActive = true;
    const rect = joystickContainer.getBoundingClientRect();
    joyCenter.x = rect.left + rect.width / 2;
    joyCenter.y = rect.top + rect.height / 2;
    const t = e.touches[0];
    joyMove(t.clientX, t.clientY);
  }
  function joyMove(x, y) {
    const dx = x - joyCenter.x;
    const dy = y - joyCenter.y;
    const max = 50;
    let d = Math.hypot(dx, dy);
    let nx = dx, ny = dy;
    if (d > max) {
      nx = dx * max / d;
      ny = dy * max / d;
    }
    joyVector.x = nx / max;
    joyVector.y = ny / max;
    joystick.style.transform = `translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;
  }
  function joyEnd(e) {
    if (e) e.preventDefault();
    joyActive = false;
    joyVector.x = 0;
    joyVector.y = 0;
    joystick.style.transform = 'translate(-50%, -50%)';
  }

  if (isMobile) {
    joystickContainer.addEventListener('touchstart', joyStart, { passive: false });
    joystickContainer.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      joyMove(t.clientX, t.clientY);
    }, { passive: false });
    joystickContainer.addEventListener('touchend', joyEnd, { passive: false });
    joystickContainer.addEventListener('touchcancel', joyEnd, { passive: false });

    driftButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      driftTouch = true;
    }, { passive: false });
    driftButton.addEventListener('touchend', (e) => {
      e.preventDefault();
      driftTouch = false;
    }, { passive: false });
    driftButton.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      driftTouch = false;
    }, { passive: false });
  }

  // Camera
  let camX = -8, camY = 5, camZ = -8;

  function update(dt) {
    let forwardInput = 0;
    let steerInput = 0;

    if (keys['w']) forwardInput += 1;
    if (keys['s']) forwardInput -= 1;
    if (keys['a']) steerInput += 1;
    if (keys['d']) steerInput -= 1;

    if (isMobile && (Math.abs(joyVector.x) > 0.05 || Math.abs(joyVector.y) > 0.05)) {
      forwardInput += -joyVector.y;
      steerInput += joyVector.x;
    }

    const drifting = keys['shift'] || driftTouch;

    // Parameters tuned for "feels good"
    const accel = 22;          // forward accel
    const baseGrip = drifting ? 0.08 : 0.22; // how strongly velocity aligns to heading
    const maxSpeed = 28;
    const friction = 1.8;
    const drag = 0.35;
    const baseTurnRate = 3.8;
    const driftTurnBoost = 1.4;

    // Heading and forward/right vectors
    const forwardDir = { x: Math.sin(taxi.heading), z: Math.cos(taxi.heading) };
    const rightDir   = { x: Math.cos(taxi.heading), z: -Math.sin(taxi.heading) };

    // Accelerate along forward
    if (Math.abs(forwardInput) > 0.01) {
      taxi.vx += forwardDir.x * accel * forwardInput * dt;
      taxi.vz += forwardDir.z * accel * forwardInput * dt;
    }

    // Friction + drag
    taxi.vx *= (1 - drag * dt);
    taxi.vz *= (1 - drag * dt);

    const speed = Math.hypot(taxi.vx, taxi.vz);
    if (speed > 0) {
      const slow = friction * dt;
      const newSpeed = Math.max(speed - slow, 0);
      const scale = newSpeed / speed;
      taxi.vx *= scale;
      taxi.vz *= scale;
    }

    // Clamp speed
    let clampedSpeed = Math.min(speed, drifting ? maxSpeed * 1.1 : maxSpeed);
    if (speed > 0) {
      const scale = clampedSpeed / speed;
      taxi.vx *= scale;
      taxi.vz *= scale;
    }

    // Steering based on speed
    const speedFactor = Math.min(clampedSpeed / 10, 1);
    let turnRate = baseTurnRate + (drifting ? driftTurnBoost : 0);
    turnRate *= speedFactor;
    taxi.heading += steerInput * turnRate * dt * (clampedSpeed >= 0 ? 1 : -1);

    // Drift: velocity doesn't instantly align to heading
    if (clampedSpeed > 0.1) {
      const velDir = { x: taxi.vx / clampedSpeed, z: taxi.vz / clampedSpeed };
      const grip = baseGrip;
      const targetDir = {
        x: velDir.x * (1 - grip) + forwardDir.x * grip,
        z: velDir.z * (1 - grip) + forwardDir.z * grip
      };
      const len = Math.hypot(targetDir.x, targetDir.z) || 1;
      const ndx = targetDir.x / len;
      const ndz = targetDir.z / len;
      taxi.vx = ndx * clampedSpeed;
      taxi.vz = ndz * clampedSpeed;
    }

    // Drift kick: small lateral impulse
    if (drifting && forwardInput > 0.2 && clampedSpeed > 6) {
      const kick = 12 * dt;
      const side = (Math.random() > 0.5 ? 1 : -1);
      taxi.vx += rightDir.x * kick * side;
      taxi.vz += rightDir.z * kick * side;
    }

    // Integrate position
    taxi.x += taxi.vx * dt;
    taxi.z += taxi.vz * dt;

    // Camera follow
    const camDist = 9;
    const camHeight = 4.2;
    const targetCamX = taxi.x - Math.sin(taxi.heading) * camDist;
    const targetCamZ = taxi.z - Math.cos(taxi.heading) * camDist;
    const targetCamY = taxi.y + camHeight;

    const lerp = (a, b, t) => a + (b - a) * t;
    camX = lerp(camX, targetCamX, 0.09);
    camY = lerp(camY, targetCamY, 0.09);
    camZ = lerp(camZ, targetCamZ, 0.09);
  }

  function getCamera() {
    return lookAt([camX, camY, camZ], [taxi.x, taxi.y + 0.3, taxi.z], [0, 1, 0]);
  }

  function render() {
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0.01, 0.01, 0.02, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const aspect = gl.drawingBufferWidth / gl.drawingBufferHeight;
    const proj = perspective(Math.PI / 3, aspect, 0.1, 600.0);
    const view = getCamera();

    gl.uniformMatrix4fv(uProjection, false, proj);
    gl.uniformMatrix4fv(uView, false, view);

    // Lighting: dark, dingy, side-lit
    gl.uniform3f(uLightDir, 0.3, 0.9, 0.4);
    gl.uniform3f(uAmbient, 0.10, 0.10, 0.13);

    // Ground (asphalt)
    let model = identity();
    model = translate(model, [0, -0.5, 0]);
    model = scale(model, [260, 0.5, 260]);
    drawCube(groundCube, model);

    // Buildings
    for (const b of buildings) {
      // main dark block
      let m = identity();
      m = translate(m, [b.x, b.h / 2, b.z]);
      m = scale(m, [7, b.h, 7]);
      drawCube(buildingCube, m);

      // window band
      let w = identity();
      w = translate(w, [b.x, b.h * 0.6, b.z]);
      w = scale(w, [7.2, b.h * 0.05, 7.2]);
      drawCube(windowCube, w);
    }

    // Taxi
    let taxiModel = identity();
    taxiModel = translate(taxiModel, [taxi.x, taxi.y, taxi.z]);
    taxiModel = rotateY(taxiModel, taxi.heading);
    taxiModel = scale(taxiModel, [1.6, 0.7, 3.2]);
    drawCube(taxiCube, taxiModel);
  }

  let lastTime = 0;
  function loop(time) {
    const dt = Math.min((time - lastTime) / 1000, 0.05);
    lastTime = time;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
