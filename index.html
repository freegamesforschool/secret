<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Raw WebGL Taxi Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, sans-serif;
    }
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 13px;
      z-index: 10;
    }
    #hud strong {
      font-size: 15px;
    }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<div id="hud">
  <strong>Raw WebGL Taxi</strong><br>
  W/S – accelerate / brake • A/D – steer<br>
  <span id="score">Passengers: 0</span>
</div>

<script>
// ====== Basic setup ======
const canvas = document.getElementById("glcanvas");
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

const gl = canvas.getContext("webgl");
if (!gl) {
  alert("WebGL not supported");
}

// ====== Shaders ======
const vsSource = `
attribute vec3 aPosition;
attribute vec3 aColor;

uniform mat4 uMVP;

varying vec3 vColor;

void main(void) {
  gl_Position = uMVP * vec4(aPosition, 1.0);
  vColor = aColor;
}
`;

const fsSource = `
precision mediump float;
varying vec3 vColor;
void main(void) {
  gl_FragColor = vec4(vColor, 1.0);
}
`;

function compileShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

const vs = compileShader(gl.VERTEX_SHADER, vsSource);
const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  console.error(gl.getProgramInfoLog(program));
}
gl.useProgram(program);

// ====== Simple mat4 utilities ======
function mat4Identity() {
  return [1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          0,0,0,1];
}

function mat4Multiply(a, b) {
  const out = new Array(16);
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      out[i*4 + j] =
        a[i*4 + 0] * b[0*4 + j] +
        a[i*4 + 1] * b[1*4 + j] +
        a[i*4 + 2] * b[2*4 + j] +
        a[i*4 + 3] * b[3*4 + j];
    }
  }
  return out;
}

function mat4Translate(m, x, y, z) {
  const t = mat4Identity();
  t[12] = x;
  t[13] = y;
  t[14] = z;
  return mat4Multiply(m, t);
}

function mat4Scale(m, x, y, z) {
  const s = mat4Identity();
  s[0] = x;
  s[5] = y;
  s[10] = z;
  return mat4Multiply(m, s);
}

function mat4RotateY(m, angle) {
  const c = Math.cos(angle);
  const s = Math.sin(angle);
  const r = [
    c, 0, -s, 0,
    0, 1,  0, 0,
    s, 0,  c, 0,
    0, 0,  0, 1
  ];
  return mat4Multiply(m, r);
}

function mat4Perspective(fovy, aspect, near, far) {
  const f = 1.0 / Math.tan(fovy / 2);
  const nf = 1 / (near - far);
  const out = new Array(16);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;

  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;

  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;

  out[12] = 0;
  out[13] = 0;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}

function mat4LookAt(eye, center, up) {
  const ex = eye[0], ey = eye[1], ez = eye[2];
  const cx = center[0], cy = center[1], cz = center[2];
  const ux = up[0], uy = up[1], uz = up[2];

  let zx = ex - cx;
  let zy = ey - cy;
  let zz = ez - cz;
  let len = Math.hypot(zx, zy, zz);
  zx /= len; zy /= len; zz /= len;

  let xx = uy * zz - uz * zy;
  let xy = uz * zx - ux * zz;
  let xz = ux * zy - uy * zx;
  len = Math.hypot(xx, xy, xz);
  xx /= len; xy /= len; xz /= len;

  let yx = zy * xz - zz * xy;
  let yy = zz * xx - zx * xz;
  let yz = zx * xy - zy * xx;
  len = Math.hypot(yx, yy, yz);
  yx /= len; yy /= len; yz /= len;

  const out = mat4Identity();
  out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
  out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
  out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
  out[12] = -(xx * ex + xy * ey + xz * ez);
  out[13] = -(yx * ex + yy * ey + yz * ez);
  out[14] = -(zx * ex + zy * ey + zz * ez);
  out[15] = 1;
  return out;
}

// ====== Geometry (cube + ground) ======
function createCube(size, color) {
  const s = size / 2;
  const positions = [
    // Front
    -s,-s, s,  s,-s, s,  s, s, s,  -s, s, s,
    // Back
    -s,-s,-s, -s, s,-s,  s, s,-s,  s,-s,-s,
    // Top
    -s, s,-s, -s, s, s,  s, s, s,  s, s,-s,
    // Bottom
    -s,-s,-s,  s,-s,-s,  s,-s, s, -s,-s, s,
    // Right
     s,-s,-s,  s, s,-s,  s, s, s,  s,-s, s,
    // Left
    -s,-s,-s, -s,-s, s, -s, s, s, -s, s,-s
  ];
  const indices = [
    0,1,2, 0,2,3,
    4,5,6, 4,6,7,
    8,9,10, 8,10,11,
    12,13,14, 12,14,15,
    16,17,18, 16,18,19,
    20,21,22, 20,22,23
  ];
  const colors = [];
  for (let i = 0; i < 24; i++) {
    colors.push(color[0], color[1], color[2]);
  }
  return { positions, indices, colors };
}

function createGround(size, color) {
  const s = size / 2;
  const positions = [
    -s, 0, -s,
     s, 0, -s,
     s, 0,  s,
    -s, 0,  s
  ];
  const indices = [0,1,2, 0,2,3];
  const colors = [];
  for (let i = 0; i < 4; i++) {
    colors.push(color[0], color[1], color[2]);
  }
  return { positions, indices, colors };
}

// Build buffers
function buildMesh(mesh) {
  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.positions), gl.STATIC_DRAW);

  const colBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh.colors), gl.STATIC_DRAW);

  const idxBuf = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(mesh.indices), gl.STATIC_DRAW);

  return { posBuf, colBuf, idxBuf, count: mesh.indices.length };
}

const taxiMesh = buildMesh(createCube(1.0, [1.0, 0.85, 0.0]));
const passengerMesh = buildMesh(createCube(0.6, [0.1, 1.0, 0.3]));
const buildingMesh = buildMesh(createCube(1.0, [0.4, 0.4, 0.9]));
const groundMesh = buildMesh(createGround(60.0, [0.12, 0.12, 0.12]));

// Random buildings
const buildings = [];
for (let i = 0; i < 40; i++) {
  const x = (Math.random() - 0.5) * 50;
  const z = (Math.random() - 0.5) * 50;
  if (Math.abs(x) < 5 && Math.abs(z) < 5) { i--; continue; }
  const h = 1.5 + Math.random() * 5;
  buildings.push({ x, z, h });
}

// ====== Attributes / uniforms ======
const aPosition = gl.getAttribLocation(program, "aPosition");
const aColor = gl.getAttribLocation(program, "aColor");
const uMVP = gl.getUniformLocation(program, "uMVP");

gl.enable(gl.DEPTH_TEST);

// ====== Input ======
const keys = {
  KeyW: false,
  KeyS: false,
  KeyA: false,
  KeyD: false
};

window.addEventListener("keydown", e => {
  if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
});
window.addEventListener("keyup", e => {
  if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
});

// ====== Game state ======
let taxiPos = { x: 0, z: 0 };
let taxiAngle = 0;
let speed = 0;
const maxSpeed = 0.25;
const accel = 0.01;
const friction = 0.008;
const steerSpeed = 0.04;

let passengerPos = randomPassengerPos();
let score = 0;
const scoreEl = document.getElementById("score");

function randomPassengerPos() {
  let x, z;
  do {
    x = (Math.random() - 0.5) * 40;
    z = (Math.random() - 0.5) * 40;
  } while (Math.abs(x) < 3 && Math.abs(z) < 3);
  return { x, z };
}

// ====== Draw helpers ======
function bindMesh(mesh) {
  gl.bindBuffer(gl.ARRAY_BUFFER, mesh.posBuf);
  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(aPosition);

  gl.bindBuffer(gl.ARRAY_BUFFER, mesh.colBuf);
  gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(aColor);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.idxBuf);
}

function drawMesh(mesh, model, view, proj) {
  const vp = mat4Multiply(proj, view);
  const mvp = mat4Multiply(vp, model);
  gl.uniformMatrix4fv(uMVP, false, new Float32Array(mvp));
  gl.drawElements(gl.TRIANGLES, mesh.count, gl.UNSIGNED_SHORT, 0);
}

// ====== Main loop ======
function loop() {
  requestAnimationFrame(loop);

  // Physics
  const forward = keys.KeyW;
  const backward = keys.KeyS;
  const left = keys.KeyA;
  const right = keys.KeyD;

  if (forward) speed += accel;
  else if (backward) speed -= accel * 0.7;
  else {
    if (speed > 0) {
      speed -= friction;
      if (speed < 0) speed = 0;
    } else if (speed < 0) {
      speed += friction;
      if (speed > 0) speed = 0;
    }
  }

  if (speed > maxSpeed) speed = maxSpeed;
  if (speed < -maxSpeed * 0.5) speed = -maxSpeed * 0.5;

  if (speed !== 0) {
    if (left) taxiAngle += steerSpeed * (speed > 0 ? 1 : -1);
    if (right) taxiAngle -= steerSpeed * (speed > 0 ? 1 : -1);
  }

  taxiPos.x += Math.sin(taxiAngle) * speed;
  taxiPos.z += Math.cos(taxiAngle) * speed;

  // Bounds
  taxiPos.x = Math.max(-28, Math.min(28, taxiPos.x));
  taxiPos.z = Math.max(-28, Math.min(28, taxiPos.z));

  // Passenger pickup
  const dx = taxiPos.x - passengerPos.x;
  const dz = taxiPos.z - passengerPos.z;
  const dist = Math.hypot(dx, dz);
  if (dist < 1.2) {
    score++;
    scoreEl.textContent = "Passengers: " + score;
    passengerPos = randomPassengerPos();
  }

  // Camera follow (third person)
  const camDist = 8;
  const camHeight = 5;
  const camX = taxiPos.x - Math.sin(taxiAngle) * camDist;
  const camZ = taxiPos.z - Math.cos(taxiAngle) * camDist;
  const camY = camHeight;

  const eye = [camX, camY, camZ];
  const center = [taxiPos.x, 0.5, taxiPos.z];
  const up = [0,1,0];

  const aspect = canvas.width / canvas.height;
  const proj = mat4Perspective(Math.PI / 3, aspect, 0.1, 200);
  const view = mat4LookAt(eye, center, up);

  // Clear
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clearColor(0.05, 0.05, 0.08, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // Draw ground
  bindMesh(groundMesh);
  let model = mat4Identity();
  drawMesh(groundMesh, model, view, proj);

  // Draw buildings
  bindMesh(buildingMesh);
  for (const b of buildings) {
    let m = mat4Identity();
    m = mat4Translate(m, b.x, b.h / 2, b.z);
    m = mat4Scale(m, 1.5, b.h, 1.5);
    drawMesh(buildingMesh, m, view, proj);
  }

  // Draw passenger
  bindMesh(passengerMesh);
  model = mat4Identity();
  model = mat4Translate(model, passengerPos.x, 0.3, passengerPos.z);
  drawMesh(passengerMesh, model, view, proj);

  // Draw taxi
  bindMesh(taxiMesh);
  model = mat4Identity();
  model = mat4Translate(model, taxiPos.x, 0.5, taxiPos.z);
  model = mat4RotateY(model, taxiAngle);
  model = mat4Scale(model, 1.4, 0.7, 2.0);
  drawMesh(taxiMesh, model, view, proj);
}

loop();
</script>
</body>
</html>
