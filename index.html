<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Taxi Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      padding: 6px 10px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
<div id="info">
  <div><b>3D Taxi</b></div>
  <div>W/S: accelerate / brake</div>
  <div>A/D: steer</div>
  <div>Space: handbrake</div>
</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
  // --- Basic setup ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202030);

  const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // --- Lights ---
  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambient);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(20, 40, 10);
  scene.add(dirLight);

  // --- Ground (road plane) ---
  const groundGeo = new THREE.PlaneGeometry(500, 500, 10, 10);
  const groundMat = new THREE.MeshStandardMaterial({
    color: 0x222222,
    roughness: 1
  });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // --- Simple city blocks (buildings) ---
  const buildingMat = new THREE.MeshStandardMaterial({ color: 0x404060 });
  const buildingGeo = new THREE.BoxGeometry(10, 20, 10);

  function addBuilding(x, z, hMult = 1) {
    const b = new THREE.Mesh(
      buildingGeo.clone().scale(1, hMult, 1),
      buildingMat
    );
    b.position.set(x, 10 * hMult, z);
    b.castShadow = true;
    b.receiveShadow = true;
    scene.add(b);
  }

  // Place buildings in a grid, leaving a rough “road” area in the middle
  for (let i = -4; i <= 4; i++) {
    for (let j = -4; j <= 4; j++) {
      if (Math.abs(i) < 2 && Math.abs(j) < 2) continue; // keep center open
      const x = i * 20;
      const z = j * 20;
      const hMult = 0.5 + Math.random() * 2.0;
      addBuilding(x, z, hMult);
    }
  }

  // --- Taxi model (simple box car) ---
  const taxiGroup = new THREE.Group();

  // Body
  const bodyGeo = new THREE.BoxGeometry(4, 1.2, 8);
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffd000 });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 1.0;
  taxiGroup.add(body);

  // Roof
  const roofGeo = new THREE.BoxGeometry(3, 1, 3.5);
  const roofMat = new THREE.MeshStandardMaterial({ color: 0xfff5a0 });
  const roof = new THREE.Mesh(roofGeo, roofMat);
  roof.position.set(0, 1.8, -0.5);
  taxiGroup.add(roof);

  // Taxi sign
  const signGeo = new THREE.BoxGeometry(1.5, 0.4, 0.8);
  const signMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
  const sign = new THREE.Mesh(signGeo, signMat);
  sign.position.set(0, 2.4, -0.5);
  taxiGroup.add(sign);

  // Wheels (just cylinders)
  const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
  const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

  function makeWheel(x, z) {
    const w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI / 2;
    w.position.set(x, 0.5, z);
    taxiGroup.add(w);
    return w;
  }

  const wheelFL = makeWheel(-1.5, -2.5);
  const wheelFR = makeWheel(1.5, -2.5);
  const wheelRL = makeWheel(-1.5, 2.5);
  const wheelRR = makeWheel(1.5, 2.5);

  taxiGroup.position.set(0, 0, 0);
  scene.add(taxiGroup);

  // --- Taxi physics-ish params ---
  let speed = 0;
  let steering = 0;
  const maxSpeed = 0.6;
  const accel = 0.01;
  const brakeDecel = 0.03;
  const friction = 0.005;
  const steeringSpeed = 0.03;
  const maxSteering = 0.04;

  const keys = {
    w: false,
    s: false,
    a: false,
    d: false,
    space: false
  };

  window.addEventListener("keydown", (e) => {
    if (e.code === "KeyW") keys.w = true;
    if (e.code === "KeyS") keys.s = true;
    if (e.code === "KeyA") keys.a = true;
    if (e.code === "KeyD") keys.d = true;
    if (e.code === "Space") keys.space = true;
  });

  window.addEventListener("keyup", (e) => {
    if (e.code === "KeyW") keys.w = false;
    if (e.code === "KeyS") keys.s = false;
    if (e.code === "KeyA") keys.a = false;
    if (e.code === "KeyD") keys.d = false;
    if (e.code === "Space") keys.space = false;
  });

  // --- Camera follow setup ---
  // Camera will follow from behind and slightly above the taxi
  function updateCamera() {
    const offset = new THREE.Vector3(0, 6, 12); // relative to taxi
    const worldOffset = offset.clone().applyQuaternion(taxiGroup.quaternion);
    const camPos = taxiGroup.position.clone().add(worldOffset);
    camera.position.lerp(camPos, 0.15); // smooth follow
    camera.lookAt(taxiGroup.position.clone().add(new THREE.Vector3(0, 2, 0)));
  }

  // --- Resize handling ---
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // --- Main loop ---
  let lastTime = performance.now();

  function animate(now) {
    requestAnimationFrame(animate);
    const dt = (now - lastTime) / 16.67; // ~60fps normalization
    lastTime = now;

    // Controls: acceleration / braking
    if (keys.w) {
      speed += accel * dt;
    } else if (keys.s) {
      speed -= accel * dt;
    } else {
      // natural friction
      if (speed > 0) {
        speed -= friction * dt;
        if (speed < 0) speed = 0;
      } else if (speed < 0) {
        speed += friction * dt;
        if (speed > 0) speed = 0;
      }
    }

    // Handbrake
    if (keys.space) {
      if (speed > 0) {
        speed -= brakeDecel * dt;
        if (speed < 0) speed = 0;
      } else if (speed < 0) {
        speed += brakeDecel * dt;
        if (speed > 0) speed = 0;
      }
    }

    // Clamp speed
    if (speed > maxSpeed) speed = maxSpeed;
    if (speed < -maxSpeed * 0.5) speed = -maxSpeed * 0.5; // reverse slower

    // Steering
    if (keys.a) {
      steering += steeringSpeed * dt;
    } else if (keys.d) {
      steering -= steeringSpeed * dt;
    } else {
      // auto-center steering
      if (steering > 0) {
        steering -= steeringSpeed * 0.5 * dt;
        if (steering < 0) steering = 0;
      } else if (steering < 0) {
        steering += steeringSpeed * 0.5 * dt;
        if (steering > 0) steering = 0;
      }
    }
    // Clamp steering
    steering = Math.max(-maxSteering, Math.min(maxSteering, steering));

    // Rotate taxi based on steering and speed
    taxiGroup.rotation.y += steering * speed * dt * 2.0;

    // Move taxi forward in its local -Z direction
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(taxiGroup.quaternion);
    taxiGroup.position.addScaledVector(forward, speed * dt * 2.0);

    // Simple wheel spin
    const wheelSpin = speed * 0.5 * dt * 10;
    wheelFL.rotation.x += wheelSpin;
    wheelFR.rotation.x += wheelSpin;
    wheelRL.rotation.x += wheelSpin;
    wheelRR.rotation.x += wheelSpin;

    // Camera follow
    updateCamera();

    renderer.render(scene, camera);
  }

  animate(performance.now());
</script>
</body>
</html>
