<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Taxi Boss Style 3D Demo</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      font-family: sans-serif;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0,0,0,0.5);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 13px;
      z-index: 10;
    }
  </style>
</head>
<body>
<div id="info">
  <strong>Taxi Boss Style 3D (Prototype)</strong><br>
  W / A / S / D or Arrow Keys – drive<br>
  Mouse drag – orbit camera<br>
</div>

<!-- Three.js CDN -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
  // === Basic setup ===
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x101018);

  const camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(0, 10, 20);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.enablePan = false;
  controls.maxPolarAngle = Math.PI / 2.1;
  controls.target.set(0, 2, 0);

  // === Lights ===
  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambient);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(10, 20, 10);
  scene.add(dirLight);

  // === Ground (road area) ===
  const groundGeo = new THREE.PlaneGeometry(200, 200);
  const groundMat = new THREE.MeshStandardMaterial({
    color: 0x222222,
    roughness: 0.9,
    metalness: 0.1
  });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // === Simple road grid ===
  const roadMat = new THREE.MeshStandardMaterial({
    color: 0x333333,
    roughness: 0.8
  });

  function createRoad(x, z, w, h, rot) {
    const geo = new THREE.PlaneGeometry(w, h);
    const mesh = new THREE.Mesh(geo, roadMat);
    mesh.rotation.x = -Math.PI / 2;
    mesh.position.set(x, 0.01, z);
    if (rot) mesh.rotation.z = rot;
    scene.add(mesh);
  }

  // A few long roads crossing like a simple city grid
  createRoad(0, 0, 200, 12, 0);      // main horizontal
  createRoad(0, 40, 200, 10, 0);
  createRoad(0, -40, 200, 10, 0);
  createRoad(0, 0, 200, 12, Math.PI / 2); // main vertical
  createRoad(40, 0, 200, 10, Math.PI / 2);
  createRoad(-40, 0, 200, 10, Math.PI / 2);

  // === Buildings ===
  const buildingMat1 = new THREE.MeshStandardMaterial({ color: 0x4444aa });
  const buildingMat2 = new THREE.MeshStandardMaterial({ color: 0xaa4444 });
  const buildingMat3 = new THREE.MeshStandardMaterial({ color: 0x44aa44 });

  function addBuilding(x, z, w, d, h, mat) {
    const geo = new THREE.BoxGeometry(w, h, d);
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, h / 2, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
  }

  // Scatter some buildings around the roads
  const mats = [buildingMat1, buildingMat2, buildingMat3];
  for (let i = 0; i < 80; i++) {
    const mat = mats[Math.floor(Math.random() * mats.length)];
    const w = 4 + Math.random() * 8;
    const d = 4 + Math.random() * 8;
    const h = 6 + Math.random() * 20;

    // keep them off the main roads a bit
    let x = (Math.random() - 0.5) * 180;
    let z = (Math.random() - 0.5) * 180;
    if (Math.abs(x) < 12 || Math.abs(z) < 12) {
      i--;
      continue;
    }
    addBuilding(x, z, w, d, h, mat);
  }

  // === Taxi (player car) ===
  const taxiGroup = new THREE.Group();

  // Body
  const bodyGeo = new THREE.BoxGeometry(2.2, 0.8, 4);
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffd000 });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.8;
  taxiGroup.add(body);

  // Roof
  const roofGeo = new THREE.BoxGeometry(1.6, 0.6, 2.2);
  const roofMat = new THREE.MeshStandardMaterial({ color: 0xfff6a0 });
  const roof = new THREE.Mesh(roofGeo, roofMat);
  roof.position.set(0, 1.3, -0.2);
  taxiGroup.add(roof);

  // Wheels
  const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 16);
  const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

  function addWheel(x, z) {
    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
    wheel.rotation.z = Math.PI / 2;
    wheel.position.set(x, 0.4, z);
    taxiGroup.add(wheel);
  }

  addWheel(1.1, 1.4);
  addWheel(-1.1, 1.4);
  addWheel(1.1, -1.4);
  addWheel(-1.1, -1.4);

  taxiGroup.position.set(0, 0, 0);
  scene.add(taxiGroup);

  // === Movement ===
  const keys = {
    ArrowUp: false,
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false,
    KeyW: false,
    KeyS: false,
    KeyA: false,
    KeyD: false
  };

  window.addEventListener("keydown", (e) => {
    if (keys.hasOwnProperty(e.code)) {
      keys[e.code] = true;
    }
  });

  window.addEventListener("keyup", (e) => {
    if (keys.hasOwnProperty(e.code)) {
      keys[e.code] = false;
    }
  });

  let speed = 0;
  let maxSpeed = 0.35;
  let accel = 0.01;
  let brake = 0.02;
  let friction = 0.008;
  let steerSpeed = 0.03;

  // === Camera follow offset ===
  const followOffset = new THREE.Vector3(0, 6, 10);
  const cameraLerpFactor = 0.08;

  // === Animation loop ===
  function animate() {
    requestAnimationFrame(animate);

    // Forward / backward
    const forwardPressed = keys.ArrowUp || keys.KeyW;
    const backwardPressed = keys.ArrowDown || keys.KeyS;

    if (forwardPressed) {
      speed += accel;
    } else if (backwardPressed) {
      speed -= accel;
    } else {
      // friction
      if (speed > 0) {
        speed -= friction;
        if (speed < 0) speed = 0;
      } else if (speed < 0) {
        speed += friction;
        if (speed > 0) speed = 0;
      }
    }

    // Clamp speed
    if (speed > maxSpeed) speed = maxSpeed;
    if (speed < -maxSpeed * 0.6) speed = -maxSpeed * 0.6;

    // Steering
    const leftPressed = keys.ArrowLeft || keys.KeyA;
    const rightPressed = keys.ArrowRight || keys.KeyD;

    if (leftPressed && speed !== 0) {
      taxiGroup.rotation.y += steerSpeed * (speed > 0 ? 1 : -1);
    }
    if (rightPressed && speed !== 0) {
      taxiGroup.rotation.y -= steerSpeed * (speed > 0 ? 1 : -1);
    }

    // Move taxi forward in its local direction
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(taxiGroup.quaternion);
    taxiGroup.position.addScaledVector(forward, speed);

    // Keep taxi roughly within bounds
    taxiGroup.position.x = THREE.MathUtils.clamp(taxiGroup.position.x, -95, 95);
    taxiGroup.position.z = THREE.MathUtils.clamp(taxiGroup.position.z, -95, 95);

    // Camera follow
    const desiredPosition = taxiGroup.position
      .clone()
      .add(
        followOffset
          .clone()
          .applyAxisAngle(new THREE.Vector3(0, 1, 0), taxiGroup.rotation.y)
      );

    camera.position.lerp(desiredPosition, cameraLerpFactor);
    controls.target.lerp(taxiGroup.position.clone().add(new THREE.Vector3(0, 1.5, 0)), 0.15);
    controls.update();

    renderer.render(scene, camera);
  }

  animate();

  // === Resize handling ===
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
