<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Taxi City Drift</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      touch-action: none;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      padding: 6px 10px;
      border-radius: 4px;
    }
    #mobileControls {
      position: absolute;
      left: 10px;
      bottom: 10px;
      width: 160px;
      height: 160px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.4);
      box-sizing: border-box;
      z-index: 20;
      display: none;
      touch-action: none;
    }
    #joystickThumb {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(255,255,255,0.4);
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    #driftButton {
      position: absolute;
      right: 20px;
      bottom: 30px;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: rgba(255,255,255,0.2);
      border: 2px solid rgba(255,255,255,0.6);
      color: #fff;
      font-family: sans-serif;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 20;
      display: none;
      touch-action: none;
    }
  </style>
</head>
<body>
<div id="info">
  <b>3D Taxi City Drift</b><br>
  <span id="pcHelp">W/S = accel/brake, A/D = steer, Space = drift</span>
  <span id="mobileHelp" style="display:none;">Use joystick to drive, DRIFT button to slide</span>
</div>

<div id="mobileControls">
  <div id="joystickThumb"></div>
</div>
<div id="driftButton">DRIFT</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
  // --- Device detection ---
  const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

  const mobileControls = document.getElementById("mobileControls");
  const joystickThumb = document.getElementById("joystickThumb");
  const driftButton = document.getElementById("driftButton");
  const pcHelp = document.getElementById("pcHelp");
  const mobileHelp = document.getElementById("mobileHelp");

  if (isMobile) {
    mobileControls.style.display = "block";
    driftButton.style.display = "flex";
    pcHelp.style.display = "none";
    mobileHelp.style.display = "inline";
  }

  // --- Three.js setup ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202030);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 0.4));
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(40, 80, 20);
  scene.add(dir);

  // --- Ground & city layout ---
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(3000, 3000),
    new THREE.MeshStandardMaterial({ color: 0x222222 })
  );
  ground.rotation.x = -Math.PI / 2;
  scene.add(ground);

  // Roads: grid of wide stripes
  const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
  const roadWidth = 18;
  const blockSize = 80; // distance between road centers

  for (let i = -8; i <= 8; i++) {
    // vertical roads (along Z)
    const vRoad = new THREE.Mesh(
      new THREE.PlaneGeometry(roadWidth, 3000),
      roadMat
    );
    vRoad.rotation.x = -Math.PI / 2;
    vRoad.position.x = i * blockSize;
    scene.add(vRoad);

    // horizontal roads (along X)
    const hRoad = new THREE.Mesh(
      new THREE.PlaneGeometry(3000, roadWidth),
      roadMat
    );
    hRoad.rotation.x = -Math.PI / 2;
    hRoad.position.z = i * blockSize;
    scene.add(hRoad);
  }

  // Buildings in blocks between roads
  const buildingGeo = new THREE.BoxGeometry(16, 20, 16);
  const buildingMat = new THREE.MeshStandardMaterial({ color: 0x505070 });

  for (let i = -7; i <= 7; i++) {
    for (let j = -7; j <= 7; j++) {
      // skip near center for spawn area
      if (Math.abs(i) < 2 && Math.abs(j) < 2) continue;

      const centerX = i * blockSize;
      const centerZ = j * blockSize;

      // four buildings per block, offset from center
      const offsets = [
        [-20, -20],
        [20, -20],
        [-20, 20],
        [20, 20]
      ];

      offsets.forEach(([ox, oz]) => {
        const hMult = 0.7 + Math.random() * 2.5;
        const b = new THREE.Mesh(
          buildingGeo.clone().scale(1, hMult, 1),
          buildingMat
        );
        b.position.set(centerX + ox, 10 * hMult, centerZ + oz);
        scene.add(b);
      });
    }
  }

  // --- Taxi model ---
  const taxi = new THREE.Group();

  const body = new THREE.Mesh(
    new THREE.BoxGeometry(4, 1.2, 8),
    new THREE.MeshStandardMaterial({ color: 0xffd000 })
  );
  body.position.y = 1;
  taxi.add(body);

  const roof = new THREE.Mesh(
    new THREE.BoxGeometry(3, 1, 3.5),
    new THREE.MeshStandardMaterial({ color: 0xfff5a0 })
  );
  roof.position.set(0, 1.8, -0.5);
  taxi.add(roof);

  const sign = new THREE.Mesh(
    new THREE.BoxGeometry(1.5, 0.4, 0.8),
    new THREE.MeshStandardMaterial({ color: 0x000000 })
  );
  sign.position.set(0, 2.4, -0.5);
  taxi.add(sign);

  const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 16);
  const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

  function wheel(x, z) {
    const w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI / 2;
    w.position.set(x, 0.5, z);
    taxi.add(w);
    return w;
  }

  const wFL = wheel(-1.5, -2.5);
  const wFR = wheel(1.5, -2.5);
  const wRL = wheel(-1.5, 2.5);
  const wRR = wheel(1.5, 2.5);

  taxi.position.set(0, 0, 0);
  scene.add(taxi);

  // --- Skid marks ---
  const skidGroup = new THREE.Group();
  scene.add(skidGroup);
  const skidMat = new THREE.MeshBasicMaterial({
    color: 0x000000,
    transparent: true,
    opacity: 0.5
  });
  const skidGeo = new THREE.PlaneGeometry(0.4, 1.5);
  const maxSkids = 400;
  const skidPool = [];

  function addSkidAt(pos, dir) {
    let skid;
    if (skidPool.length < maxSkids) {
      skid = new THREE.Mesh(skidGeo, skidMat);
      skid.rotation.x = -Math.PI / 2;
      skidGroup.add(skid);
      skidPool.push(skid);
    } else {
      skid = skidPool.shift();
      skidPool.push(skid);
    }
    skid.position.copy(pos);
    const angle = Math.atan2(dir.x, dir.z);
    skid.rotation.y = angle;
  }

  // --- Physics & controls ---
  let speed = 0;
  let steering = 0;
  const maxSpeed = 0.7;
  const accel = 0.012;
  const friction = 0.006;
  const steeringSpeed = 0.035;
  const maxSteer = 0.045;

  let vel = new THREE.Vector3(0, 0, 0);
  const driftFactor = 0.08;
  const grip = 0.9;

  const keys = { w:0, s:0, a:0, d:0, space:0 };

  if (!isMobile) {
    window.addEventListener("keydown", e => {
      if (e.code === "KeyW") keys.w = 1;
      if (e.code === "KeyS") keys.s = 1;
      if (e.code === "KeyA") keys.a = 1;
      if (e.code === "KeyD") keys.d = 1;
      if (e.code === "Space") keys.space = 1;
    });
    window.addEventListener("keyup", e => {
      if (e.code === "KeyW") keys.w = 0;
      if (e.code === "KeyS") keys.s = 0;
      if (e.code === "KeyA") keys.a = 0;
      if (e.code === "KeyD") keys.d = 0;
      if (e.code === "Space") keys.space = 0;
    });
  }

  // --- Mobile joystick & drift button ---
  let joyActive = false;
  let joyCenter = { x: 0, y: 0 };
  let joyVec = { x: 0, y: 0 };

  if (isMobile) {
    const rect = mobileControls.getBoundingClientRect();
    joyCenter.x = rect.left + rect.width / 2;
    joyCenter.y = rect.top + rect.height / 2;

    function updateJoystickPos(x, y) {
      const dx = x - joyCenter.x;
      const dy = y - joyCenter.y;
      const maxR = rect.width / 2 - 20;
      const dist = Math.sqrt(dx*dx + dy*dy) || 1;
      const clamped = Math.min(dist, maxR);
      const nx = dx / dist;
      const ny = dy / dist;
      joystickThumb.style.left = (50 + (clamped * nx) / (rect.width / 2) * 50) + "%";
      joystickThumb.style.top  = (50 + (clamped * ny) / (rect.height / 2) * 50) + "%";
      joyVec.x = clamped / maxR * nx;
      joyVec.y = clamped / maxR * ny;
    }

    function resetJoystick() {
      joystickThumb.style.left = "50%";
      joystickThumb.style.top = "50%";
      joyVec.x = 0;
      joyVec.y = 0;
    }

    mobileControls.addEventListener("touchstart", e => {
      e.preventDefault();
      joyActive = true;
      const t = e.touches[0];
      updateJoystickPos(t.clientX, t.clientY);
    }, { passive: false });

    mobileControls.addEventListener("touchmove", e => {
      e.preventDefault();
      if (!joyActive) return;
      const t = e.touches[0];
      updateJoystickPos(t.clientX, t.clientY);
    }, { passive: false });

    mobileControls.addEventListener("touchend", e => {
      e.preventDefault();
      joyActive = false;
      resetJoystick();
    }, { passive: false });

    driftButton.addEventListener("touchstart", e => {
      e.preventDefault();
      keys.space = 1;
    }, { passive: false });

    driftButton.addEventListener("touchend", e => {
      e.preventDefault();
      keys.space = 0;
    }, { passive: false });
  }

  // --- Camera follow ---
  function updateCamera() {
    const offset = new THREE.Vector3(0, 7, 14).applyQuaternion(taxi.quaternion);
    const target = taxi.position.clone().add(offset);
    camera.position.lerp(target, 0.15);
    camera.lookAt(taxi.position.clone().add(new THREE.Vector3(0, 2, 0)));
  }

  // --- Main loop ---
  let last = performance.now();
  function animate(now) {
    requestAnimationFrame(animate);
    const dt = (now - last) / 16.67;
    last = now;

    // Map mobile joystick to keys-like intent
    if (isMobile) {
      // joyVec.y: up negative, down positive (screen coords)
      const forwardInput = -joyVec.y; // up = accelerate
      const steerInput = joyVec.x;    // right = positive

      keys.w = forwardInput > 0.2 ? 1 : 0;
      keys.s = forwardInput < -0.2 ? 1 : 0;

      if (steerInput > 0.2) {
        keys.d = 1; keys.a = 0;
      } else if (steerInput < -0.2) {
        keys.a = 1; keys.d = 0;
      } else {
        keys.a = 0; keys.d = 0;
      }
    }

    // Acceleration / braking
    if (keys.w) speed += accel * dt;
    else if (keys.s) speed -= accel * dt;
    else {
      if (speed > 0) speed -= friction * dt;
      if (speed < 0) speed += friction * dt;
    }

    if (keys.space) speed *= 0.9;

    speed = Math.max(-0.3, Math.min(maxSpeed, speed));

    // Steering
    if (keys.a) steering += steeringSpeed * dt;
    else if (keys.d) steering -= steeringSpeed * dt;
    else steering *= 0.9;

    steering = Math.max(-maxSteer, Math.min(maxSteer, steering));

    // Rotate taxi
    taxi.rotation.y += steering * speed * dt * 2;

    // Drift physics
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(taxi.quaternion);
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(taxi.quaternion);

    const forwardVel = forward.clone().multiplyScalar(vel.dot(forward));
    let sideVel = right.clone().multiplyScalar(vel.dot(right));

    sideVel.multiplyScalar(grip);
    sideVel.add(right.clone().multiplyScalar(steering * speed * driftFactor));

    vel = forwardVel.add(sideVel);
    vel.add(forward.clone().multiplyScalar(speed * dt * 2));

    taxi.position.add(vel);

    // Skid marks when sliding sideways
    const sideSpeed = Math.abs(vel.dot(right));
    if (sideSpeed > 0.05 && Math.abs(speed) > 0.1) {
      const rearOffsetL = new THREE.Vector3(-1.2, 0.05, 2.5).applyQuaternion(taxi.quaternion);
      const rearOffsetR = new THREE.Vector3(1.2, 0.05, 2.5).applyQuaternion(taxi.quaternion);
      const posL = taxi.position.clone().add(rearOffsetL);
      const posR = taxi.position.clone().add(rearOffsetR);
      addSkidAt(posL, forward);
      addSkidAt(posR, forward);
    }

    // Wheel spin
    const spin = speed * dt * 5;
    wFL.rotation.x += spin;
    wFR.rotation.x += spin;
    wRL.rotation.x += spin;
    wRR.rotation.x += spin;

    updateCamera();
    renderer.render(scene, camera);
  }

  animate(performance.now());

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);

    if (isMobile) {
      const rect = mobileControls.getBoundingClientRect();
      joyCenter.x = rect.left + rect.width / 2;
      joyCenter.y = rect.top + rect.height / 2;
    }
  });
</script>
</body>
</html>
