<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Taxi Drift</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #05070a;
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    display: block;
    background: #10141c;
  }

  #joystickContainer, #driftButton {
    position: fixed;
    z-index: 10;
    touch-action: none;
  }

  #joystickContainer {
    left: 10px;
    bottom: 10px;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: 2px solid #666;
    display: none; /* shown via JS if mobile */
  }
  #joystick {
    position: absolute;
    left: 50%;
    top: 50%;
    width: 60px;
    height: 60px;
    margin-left: -30px;
    margin-top: -30px;
    border-radius: 50%;
    background: rgba(255,255,255,0.25);
  }

  #driftButton {
    right: 10px;
    bottom: 30px;
    width: 90px;
    height: 90px;
    border-radius: 50%;
    background: rgba(255,255,0,0.2);
    border: 2px solid #cc0;
    color: #fff;
    font-weight: bold;
    font-family: sans-serif;
    display: none; /* shown via JS if mobile */
    align-items: center;
    justify-content: center;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="joystickContainer">
  <div id="joystick"></div>
</div>
<div id="driftButton">DRIFT</div>

<script>
(function() {
  const canvas = document.getElementById('game');
  const gl = canvas.getContext('webgl', { antialias: true }) || canvas.getContext('experimental-webgl');
  if (!gl) {
    alert('WebGL not supported');
    return;
  }

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
  window.addEventListener('resize', resize);
  resize();

  // Mobile detection
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const joystickContainer = document.getElementById('joystickContainer');
  const joystick = document.getElementById('joystick');
  const driftButton = document.getElementById('driftButton');
  if (isMobile) {
    joystickContainer.style.display = 'block';
    driftButton.style.display = 'flex';
  }

  // Shaders with lighting
  const vsSource = `
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec3 aColor;
    uniform mat4 uProjection;
    uniform mat4 uView;
    uniform mat4 uModel;
    uniform vec3 uLightDir;
    uniform vec3 uAmbient;
    varying vec3 vColor;
    void main(void) {
      vec4 worldPos = uModel * vec4(aPosition, 1.0);
      vec3 worldNormal = normalize(mat3(uModel) * aNormal);
      float diff = max(dot(-uLightDir, worldNormal), 0.0);
      vec3 litColor = aColor * (uAmbient + diff);
      vColor = litColor;
      gl_Position = uProjection * uView * worldPos;
    }
  `;
  const fsSource = `
    precision mediump float;
    varying vec3 vColor;
    void main(void) {
      gl_FragColor = vec4(vColor, 1.0);
    }
  `;

  function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  const vs = compileShader(gl.VERTEX_SHADER, vsSource);
  const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);

  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
  }
  gl.useProgram(program);

  const aPosition = gl.getAttribLocation(program, 'aPosition');
  const aNormal = gl.getAttribLocation(program, 'aNormal');
  const aColor = gl.getAttribLocation(program, 'aColor');
  const uProjection = gl.getUniformLocation(program, 'uProjection');
  const uView = gl.getUniformLocation(program, 'uView');
  const uModel = gl.getUniformLocation(program, 'uModel');
  const uLightDir = gl.getUniformLocation(program, 'uLightDir');
  const uAmbient = gl.getUniformLocation(program, 'uAmbient');

  // Matrices
  function identity() {
    const out = new Float32Array(16);
    out[0] = out[5] = out[10] = out[15] = 1;
    return out;
  }
  function translate(m, v) {
    const [x, y, z] = v;
    const out = m.slice(0);
    out[12] = m[0] * x + m[4] * y + m[8] * z + m[12];
    out[13] = m[1] * x + m[5] * y + m[9] * z + m[13];
    out[14] = m[2] * x + m[6] * y + m[10] * z + m[14];
    out[15] = m[3] * x + m[7] * y + m[11] * z + m[15];
    return out;
  }
  function scale(m, v) {
    const [x, y, z] = v;
    const out = m.slice(0);
    out[0] *= x; out[1] *= x; out[2] *= x; out[3] *= x;
    out[4] *= y; out[5] *= y; out[6] *= y; out[7] *= y;
    out[8] *= z; out[9] *= z; out[10] *= z; out[11] *= z;
    return out;
  }
  function rotateY(m, rad) {
    const c = Math.cos(rad);
    const s = Math.sin(rad);
    const out = new Float32Array(16);
    out[0] = m[0] * c + m[8] * s;
    out[1] = m[1] * c + m[9] * s;
    out[2] = m[2] * c + m[10] * s;
    out[3] = m[3] * c + m[11] * s;
    out[8] = m[0] * -s + m[8] * c;
    out[9] = m[1] * -s + m[9] * c;
    out[10] = m[2] * -s + m[10] * c;
    out[11] = m[3] * -s + m[11] * c;
    out[4] = m[4];
    out[5] = m[5];
    out[6] = m[6];
    out[7] = m[7];
    out[12] = m[12];
    out[13] = m[13];
    out[14] = m[14];
    out[15] = m[15];
    return out;
  }
  function perspective(fovy, aspect, near, far) {
    const f = 1.0 / Math.tan(fovy / 2);
    const nf = 1 / (near - far);
    const out = new Float32Array(16);
    out[0] = f / aspect;
    out[5] = f;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[14] = (2 * far * near) * nf;
    return out;
  }
  function lookAt(eye, center, up) {
    const [ex, ey, ez] = eye;
    const [cx, cy, cz] = center;
    const [ux, uy, uz] = up;

    let zx = ex - cx, zy = ey - cy, zz = ez - cz;
    let len = Math.hypot(zx, zy, zz);
    zx /= len; zy /= len; zz /= len;

    let xx = uy * zz - uz * zy;
    let xy = uz * zx - ux * zz;
    let xz = ux * zy - uy * zx;
    len = Math.hypot(xx, xy, xz);
    xx /= len; xy /= len; xz /= len;

    let yx = zy * xz - zz * xy;
    let yy = zz * xx - zx * xz;
    let yz = zx * xy - zy * xx;
    len = Math.hypot(yx, yy, yz);
    yx /= len; yy /= len; yz /= len;

    const out = new Float32Array(16);
    out[0] = xx; out[1] = yx; out[2] = zx; out[3] = 0;
    out[4] = xy; out[5] = yy; out[6] = zy; out[7] = 0;
    out[8] = xz; out[9] = yz; out[10] = zz; out[11] = 0;
    out[12] = -(xx * ex + xy * ey + xz * ez);
    out[13] = -(yx * ex + yy * ey + yz * ez);
    out[14] = -(zx * ex + zy * ey + zz * ez);
    out[15] = 1;
    return out;
  }

  // Cube with normals
  function createCube(size, color) {
    const s = size / 2;
    const [r, g, b] = color;
    const positions = [];
    const normals = [];
    const colors = [];

    function face(nx, ny, nz, verts) {
      for (let i = 0; i < 6; i++) {
        normals.push(nx, ny, nz);
        colors.push(r, g, b);
      }
      positions.push(...verts);
    }

    // Front
    face(0, 0, 1, [
      -s, -s,  s,  s, -s,  s,  s,  s,  s,
      -s, -s,  s,  s,  s,  s, -s,  s,  s
    ]);
    // Back
    face(0, 0, -1, [
       s, -s, -s, -s, -s, -s, -s,  s, -s,
       s, -s, -s, -s,  s, -s,  s,  s, -s
    ]);
    // Left
    face(-1, 0, 0, [
      -s, -s, -s, -s, -s,  s, -s,  s,  s,
      -s, -s, -s, -s,  s,  s, -s,  s, -s
    ]);
    // Right
    face(1, 0, 0, [
       s, -s,  s,  s, -s, -s,  s,  s, -s,
       s, -s,  s,  s,  s, -s,  s,  s,  s
    ]);
    // Top
    face(0, 1, 0, [
      -s,  s,  s,  s,  s,  s,  s,  s, -s,
      -s,  s,  s,  s,  s, -s, -s,  s, -s
    ]);
    // Bottom
    face(0, -1, 0, [
      -s, -s, -s,  s, -s, -s,  s, -s,  s,
      -s, -s, -s,  s, -s,  s, -s, -s,  s
    ]);

    return {
      positions: new Float32Array(positions),
      normals: new Float32Array(normals),
      colors: new Float32Array(colors)
    };
  }

  const taxiCube = createCube(1, [1.0, 0.95, 0.1]);
  const buildingCube = createCube(1, [0.2, 0.4, 0.9]);
  const groundCube = createCube(1, [0.1, 0.35, 0.1]);

  const positionBuffer = gl.createBuffer();
  const normalBuffer = gl.createBuffer();
  const colorBuffer = gl.createBuffer();

  function drawCube(cube, modelMatrix) {
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, cube.positions, gl.STATIC_DRAW);
    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aPosition);

    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, cube.normals, gl.STATIC_DRAW);
    gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aNormal);

    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, cube.colors, gl.STATIC_DRAW);
    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aColor);

    gl.uniformMatrix4fv(uModel, false, modelMatrix);
    gl.drawArrays(gl.TRIANGLES, 0, cube.positions.length / 3);
  }

  // Scene: skyscrapers
  const buildings = [];
  for (let i = 0; i < 80; i++) {
    const ring = 40 + Math.random() * 80;
    const angle = Math.random() * Math.PI * 2;
    const x = Math.cos(angle) * ring;
    const z = Math.sin(angle) * ring;
    const h = 15 + Math.random() * 35;
    buildings.push({ x, z, h });
  }

  // Taxi physics (medium weight)
  let taxi = {
    x: 0,
    y: 0.5,
    z: 0,
    heading: 0,   // visual heading
    vx: 0,
    vz: 0
  };

  const keys = {};
  window.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if (e.key === ' ') e.preventDefault();
  });
  window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  // Mobile joystick + drift
  let joyActive = false;
  let joyCenter = { x: 0, y: 0 };
  let joyVector = { x: 0, y: 0 };
  let driftTouch = false;

  function joyStart(e) {
    e.preventDefault();
    joyActive = true;
    const rect = joystickContainer.getBoundingClientRect();
    joyCenter.x = rect.left + rect.width / 2;
    joyCenter.y = rect.top + rect.height / 2;
    const t = e.touches[0];
    joyMove(t.clientX, t.clientY);
  }
  function joyMove(x, y) {
    const dx = x - joyCenter.x;
    const dy = y - joyCenter.y;
    const max = 50;
    let d = Math.hypot(dx, dy);
    let nx = dx, ny = dy;
    if (d > max) {
      nx = dx * max / d;
      ny = dy * max / d;
    }
    joyVector.x = nx / max;
    joyVector.y = ny / max;
    joystick.style.transform = `translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;
  }
  function joyEnd(e) {
    if (e) e.preventDefault();
    joyActive = false;
    joyVector.x = 0;
    joyVector.y = 0;
    joystick.style.transform = 'translate(-50%, -50%)';
  }

  if (isMobile) {
    joystickContainer.addEventListener('touchstart', joyStart, { passive: false });
    joystickContainer.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      joyMove(t.clientX, t.clientY);
    }, { passive: false });
    joystickContainer.addEventListener('touchend', joyEnd, { passive: false });
    joystickContainer.addEventListener('touchcancel', joyEnd, { passive: false });

    driftButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      driftTouch = true;
    }, { passive: false });
    driftButton.addEventListener('touchend', (e) => {
      e.preventDefault();
      driftTouch = false;
    }, { passive: false });
    driftButton.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      driftTouch = false;
    }, { passive: false });
  }

  // Camera
  let camX = -6, camY = 4, camZ = -6;

  function update(dt) {
    // Input
    let forwardInput = 0;
    let steerInput = 0;

    if (keys['w']) forwardInput += 1;
    if (keys['s']) forwardInput -= 1;
    if (keys['a']) steerInput += 1;
    if (keys['d']) steerInput -= 1;

    if (isMobile && (Math.abs(joyVector.x) > 0.05 || Math.abs(joyVector.y) > 0.05)) {
      forwardInput += -joyVector.y;
      steerInput += joyVector.x;
    }

    const drifting = keys['shift'] || driftTouch;

    // Medium-weight taxi parameters
    const accel = 18;
    const maxSpeed = 25;
    const baseTurnRate = 3.5;
    const driftTurnBoost = 1.2;
    const forwardFriction = 2.0;
    const lateralFriction = drifting ? 3.0 : 7.0; // lower when drifting -> more slide
    const drag = 0.4;

    // Compute forward & right vectors from heading
    const forwardDir = { x: Math.sin(taxi.heading), z: Math.cos(taxi.heading) };
    const rightDir = { x: Math.cos(taxi.heading), z: -Math.sin(taxi.heading) };

    // Decompose velocity into forward + lateral
    const vForward = taxi.vx * forwardDir.x + taxi.vz * forwardDir.z;
    const vLateral = taxi.vx * rightDir.x + taxi.vz * rightDir.z;

    let newVForward = vForward;
    let newVLateral = vLateral;

    // Acceleration along forward
    newVForward += forwardInput * accel * dt;

    // Friction
    const signF = newVForward >= 0 ? 1 : -1;
    newVForward -= signF * forwardFriction * dt;
    if (Math.sign(newVForward) !== signF) newVForward = 0;

    // Lateral friction (grip)
    const signL = newVLateral >= 0 ? 1 : -1;
    newVLateral -= signL * lateralFriction * dt;
    if (Math.sign(newVLateral) !== signL) newVLateral = 0;

    // Drag
    newVForward *= (1 - drag * dt);
    newVLateral *= (1 - drag * dt);

    // Clamp speed
    const speed = Math.hypot(newVForward, newVLateral);
    const max = drifting ? maxSpeed * 1.1 : maxSpeed;
    if (speed > max) {
      const scale = max / speed;
      newVForward *= scale;
      newVLateral *= scale;
    }

    // Recompose velocity
    taxi.vx = forwardDir.x * newVForward + rightDir.x * newVLateral;
    taxi.vz = forwardDir.z * newVForward + rightDir.z * newVLateral;

    // Steering based on forward speed
    const speedFactor = Math.min(Math.abs(newVForward) / 10, 1);
    let turnRate = baseTurnRate + (drifting ? driftTurnBoost : 0);
    turnRate *= speedFactor;
    taxi.heading += steerInput * turnRate * dt * (newVForward >= 0 ? 1 : -1);

    // Drift kick: small random lateral impulse when drifting and pressing forward
    if (drifting && forwardInput > 0.2 && speed > 5) {
      const kick = 10 * dt;
      taxi.vx += rightDir.x * kick * (Math.random() > 0.5 ? 1 : -1);
      taxi.vz += rightDir.z * kick * (Math.random() > 0.5 ? 1 : -1);
    }

    // Integrate position
    taxi.x += taxi.vx * dt;
    taxi.z += taxi.vz * dt;

    // Camera follow (smooth)
    const camDist = 8;
    const camHeight = 4;
    const targetCamX = taxi.x - Math.sin(taxi.heading) * camDist;
    const targetCamZ = taxi.z - Math.cos(taxi.heading) * camDist;
    const targetCamY = taxi.y + camHeight;

    const lerp = (a, b, t) => a + (b - a) * t;
    camX = lerp(camX, targetCamX, 0.08);
    camY = lerp(camY, targetCamY, 0.08);
    camZ = lerp(camZ, targetCamZ, 0.08);
  }

  function getCamera() {
    return lookAt([camX, camY, camZ], [taxi.x, taxi.y, taxi.z], [0, 1, 0]);
  }

  function render() {
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0.03, 0.04, 0.07, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const aspect = gl.drawingBufferWidth / gl.drawingBufferHeight;
    const proj = perspective(Math.PI / 3, aspect, 0.1, 500.0);
    const view = getCamera();

    gl.uniformMatrix4fv(uProjection, false, proj);
    gl.uniformMatrix4fv(uView, false, view);

    // Lighting
    gl.uniform3f(uLightDir, 0.4, 1.0, 0.6);
    gl.uniform3f(uAmbient, 0.25, 0.25, 0.28);

    // Ground
    let model = identity();
    model = translate(model, [0, -0.5, 0]);
    model = scale(model, [200, 0.5, 200]);
    drawCube(groundCube, model);

    // Buildings
    for (const b of buildings) {
      let m = identity();
      m = translate(m, [b.x, b.h / 2, b.z]);
      m = scale(m, [6, b.h, 6]);
      drawCube(buildingCube, m);
    }

    // Taxi
    let taxiModel = identity();
    taxiModel = translate(taxiModel, [taxi.x, taxi.y, taxi.z]);
    taxiModel = rotateY(taxiModel, taxi.heading);
    taxiModel = scale(taxiModel, [1.6, 0.7, 3.2]);
    drawCube(taxiCube, taxiModel);
  }

  let lastTime = 0;
  function loop(time) {
    const dt = Math.min((time - lastTime) / 1000, 0.05);
    lastTime = time;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
