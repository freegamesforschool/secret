<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Smooth 3D Taxi</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #111;
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    display: block;
    background: #222;
  }

  /* Mobile joystick */
  #joystickContainer {
    position: fixed;
    left: 10px;
    bottom: 10px;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: 2px solid #666;
    touch-action: none;
  }
  #joystick {
    position: absolute;
    left: 50%;
    top: 50%;
    width: 60px;
    height: 60px;
    margin-left: -30px;
    margin-top: -30px;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
    touch-action: none;
  }

  #driftButton {
    position: fixed;
    right: 10px;
    bottom: 30px;
    width: 90px;
    height: 90px;
    border-radius: 50%;
    background: rgba(255,255,0,0.2);
    border: 2px solid #cc0;
    color: #fff;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    touch-action: none;
  }

  @media (min-width: 900px) {
    #joystickContainer, #driftButton {
      display: none;
    }
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="joystickContainer">
  <div id="joystick"></div>
</div>
<div id="driftButton">DRIFT</div>

<script>
(function() {
  const canvas = document.getElementById('game');
  const gl = canvas.getContext('webgl', { antialias: true });

  function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
  addEventListener('resize', resize);
  resize();

  // SHADERS
  const vsSource = `
    attribute vec3 aPosition;
    attribute vec3 aColor;
    uniform mat4 uProjection;
    uniform mat4 uView;
    uniform mat4 uModel;
    varying vec3 vColor;
    void main() {
      gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.0);
      vColor = aColor;
    }
  `;
  const fsSource = `
    precision mediump float;
    varying vec3 vColor;
    void main() {
      gl_FragColor = vec4(vColor, 1.0);
    }
  `;

  function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    return s;
  }

  const vs = compile(gl.VERTEX_SHADER, vsSource);
  const fs = compile(gl.FRAGMENT_SHADER, fsSource);

  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  gl.useProgram(program);

  const aPosition = gl.getAttribLocation(program, "aPosition");
  const aColor = gl.getAttribLocation(program, "aColor");
  const uProjection = gl.getUniformLocation(program, "uProjection");
  const uView = gl.getUniformLocation(program, "uView");
  const uModel = gl.getUniformLocation(program, "uModel");

  // MATRIX HELPERS
  function identity() {
    const m = new Float32Array(16);
    m[0]=m[5]=m[10]=m[15]=1;
    return m;
  }
  function translate(m, v) {
    const out = m.slice(0);
    out[12] += v[0];
    out[13] += v[1];
    out[14] += v[2];
    return out;
  }
  function scale(m, v) {
    const out = m.slice(0);
    out[0]*=v[0]; out[5]*=v[1]; out[10]*=v[2];
    return out;
  }
  function rotateY(m, r) {
    const c = Math.cos(r), s = Math.sin(r);
    const out = m.slice(0);
    out[0] = c; out[2] = s;
    out[8] = -s; out[10] = c;
    return out;
  }
  function perspective(fov, aspect, near, far) {
    const f = 1 / Math.tan(fov/2);
    const nf = 1/(near-far);
    const m = new Float32Array(16);
    m[0]=f/aspect;
    m[5]=f;
    m[10]=(far+near)*nf;
    m[11]=-1;
    m[14]=(2*far*near)*nf;
    return m;
  }
  function lookAt(eye, center, up) {
    const [ex,ey,ez]=eye;
    const [cx,cy,cz]=center;
    let zx=ex-cx, zy=ey-cy, zz=ez-cz;
    let len=Math.hypot(zx,zy,zz);
    zx/=len; zy/=len; zz/=len;

    let xx=up[1]*zz - up[2]*zy;
    let xy=up[2]*zx - up[0]*zz;
    let xz=up[0]*zy - up[1]*zx;
    len=Math.hypot(xx,xy,xz);
    xx/=len; xy/=len; xz/=len;

    let yx=zy*xz - zz*xy;
    let yy=zz*xx - zx*xz;
    let yz=zx*xy - zy*xx;
    len=Math.hypot(yx,yy,yz);
    yx/=len; yy/=len; yz/=len;

    const m=new Float32Array(16);
    m[0]=xx; m[1]=yx; m[2]=zx; m[3]=0;
    m[4]=xy; m[5]=yy; m[6]=zy; m[7]=0;
    m[8]=xz; m[9]=yz; m[10]=zz; m[11]=0;
    m[12]=-(xx*ex+xy*ey+xz*ez);
    m[13]=-(yx*ex+yy*ey+yz*ez);
    m[14]=-(zx*ex+zy*ey+zz*ez);
    m[15]=1;
    return m;
  }

  // CUBE
  function cube(size, color) {
    const s = size/2;
    const [r,g,b] = color;
    const p = [
      // front
      -s,-s,s,  s,-s,s,  s,s,s,
      -s,-s,s,  s,s,s,  -s,s,s,
      // back
      s,-s,-s, -s,-s,-s, -s,s,-s,
      s,-s,-s, -s,s,-s,  s,s,-s,
      // left
      -s,-s,-s, -s,-s,s, -s,s,s,
      -s,-s,-s, -s,s,s, -s,s,-s,
      // right
      s,-s,s,  s,-s,-s, s,s,-s,
      s,-s,s,  s,s,-s,  s,s,s,
      // top
      -s,s,s,  s,s,s,  s,s,-s,
      -s,s,s,  s,s,-s, -s,s,-s,
      // bottom
      -s,-s,-s, s,-s,-s, s,-s,s,
      -s,-s,-s, s,-s,s, -s,-s,s
    ];
    const c = [];
    for (let i=0;i<36;i++) c.push(r,g,b);
    return { pos:new Float32Array(p), col:new Float32Array(c) };
  }

  const taxiCube = cube(1, [1,1,0]);
  const buildingCube = cube(1, [0.3,0.3,0.9]);
  const groundCube = cube(1, [0.1,0.5,0.1]);

  const posBuf = gl.createBuffer();
  const colBuf = gl.createBuffer();

  function draw(c, model) {
    gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
    gl.bufferData(gl.ARRAY_BUFFER, c.pos, gl.STATIC_DRAW);
    gl.vertexAttribPointer(aPosition,3,gl.FLOAT,false,0,0);
    gl.enableVertexAttribArray(aPosition);

    gl.bindBuffer(gl.ARRAY_BUFFER, colBuf);
    gl.bufferData(gl.ARRAY_BUFFER, c.col, gl.STATIC_DRAW);
    gl.vertexAttribPointer(aColor,3,gl.FLOAT,false,0,0);
    gl.enableVertexAttribArray(aColor);

    gl.uniformMatrix4fv(uModel,false,model);
    gl.drawArrays(gl.TRIANGLES,0,36);
  }

  // BUILDINGS
  const buildings=[];
  for(let i=0;i<40;i++){
    buildings.push({
      x:(Math.random()-0.5)*80,
      z:(Math.random()-0.5)*80,
      h:2+Math.random()*8
    });
  }

  // TAXI STATE
  let taxi = {
    x:0, y:0.5, z:0,
    rotY:0,
    speed:0
  };

  // INPUT
  const keys={};
  addEventListener("keydown",e=>keys[e.key.toLowerCase()]=true);
  addEventListener("keyup",e=>keys[e.key.toLowerCase()]=false);

  // MOBILE JOYSTICK
  const joyC=document.getElementById("joystickContainer");
  const joy=document.getElementById("joystick");
  const driftBtn=document.getElementById("driftButton");

  let joyActive=false;
  let joyCenter={x:0,y:0};
  let joyVector={x:0,y:0};
  let driftTouch=false;

  function joyStart(e){
    e.preventDefault();
    joyActive=true;
    const r=joyC.getBoundingClientRect();
    joyCenter.x=r.left+r.width/2;
    joyCenter.y=r.top+r.height/2;
    const t=e.touches[0];
    joyMove(t.clientX,t.clientY);
  }
  function joyMove(x,y){
    const dx=x-joyCenter.x;
    const dy=y-joyCenter.y;
    const max=50;
    let d=Math.hypot(dx,dy);
    let nx=dx, ny=dy;
    if(d>max){ nx=dx*max/d; ny=dy*max/d; }
    joyVector.x=nx/max;
    joyVector.y=ny/max;
    joy.style.transform=`translate(calc(-50% + ${nx}px), calc(-50% + ${ny}px))`;
  }
  function joyEnd(){
    joyActive=false;
    joyVector.x=0; joyVector.y=0;
    joy.style.transform="translate(-50%, -50%)";
  }

  joyC.addEventListener("touchstart",e=>joyStart(e),{passive:false});
  joyC.addEventListener("touchmove",e=>{e.preventDefault(); joyMove(e.touches[0].clientX,e.touches[0].clientY);},{passive:false});
  joyC.addEventListener("touchend",joyEnd,{passive:false});
  joyC.addEventListener("touchcancel",joyEnd,{passive:false});

  driftBtn.addEventListener("touchstart",e=>{e.preventDefault(); driftTouch=true;},{passive:false});
  driftBtn.addEventListener("touchend",e=>{e.preventDefault(); driftTouch=false;},{passive:false});

  // SMOOTH INPUT
  let forwardSmooth=0;
  let turnSmooth=0;

  // CAMERA SMOOTH
  let camX=0, camY=5, camZ=10;

  function update(dt){
    let forward=0, turn=0;

    if(keys['w']) forward+=1;
    if(keys['s']) forward-=1;
    if(keys['a']) turn+=1;
    if(keys['d']) turn-=1;

    if(Math.abs(joyVector.x)>0.05 || Math.abs(joyVector.y)>0.05){
      forward += -joyVector.y;
      turn += joyVector.x;
    }

    const drifting = keys['shift'] || driftTouch;

    // Smooth input
    const lerp=(a,b,t)=>a+(b-a)*t;
    forwardSmooth = lerp(forwardSmooth, forward, 0.12);
    turnSmooth = lerp(turnSmooth, turn, drifting ? 0.25 : 0.15);

    // Movement physics
    const accel = drifting ? 12 : 8;
    const maxSpeed = drifting ? 20 : 12;
    const friction = drifting ? 1.2 : 3.0;
    const turnSpeed = drifting ? 4.0 : 2.0;

    taxi.speed += forwardSmooth * accel * dt;
    taxi.speed = Math.max(Math.min(taxi.speed, maxSpeed), -maxSpeed*0.5);

    if(Math.abs(forwardSmooth)<0.1){
      taxi.speed = lerp(taxi.speed, 0, friction*dt);
    }

    if(Math.abs(taxi.speed)>0.1){
      taxi.rotY += turnSmooth * turnSpeed * dt * (taxi.speed>=0?1:-1);
    }

    const dx = Math.sin(taxi.rotY) * taxi.speed * dt;
    const dz = Math.cos(taxi.rotY) * taxi.speed * dt;

    taxi.x += dx;
    taxi.z += dz;

    // Smooth camera follow
    const targetX = taxi.x - Math.sin(taxi.rotY)*6;
    const targetY = taxi.y + 3;
    const targetZ = taxi.z - Math.cos(taxi.rotY)*6;

    camX = lerp(camX, targetX, 0.08);
    camY = lerp(camY, targetY, 0.08);
    camZ = lerp(camZ, targetZ, 0.08);
  }

  function getCamera(){
    return lookAt([camX,camY,camZ],[taxi.x,taxi.y,taxi.z],[0,1,0]);
  }

  function render(){
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0.05,0.05,0.08,1);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

    const aspect = gl.drawingBufferWidth/gl.drawingBufferHeight;
    const proj = perspective(Math.PI/3, aspect, 0.1, 200);
    const view = getCamera();

    gl.uniformMatrix4fv(uProjection,false,proj);
    gl.uniformMatrix4fv(uView,false,view);

    // Ground
    let m = identity();
    m = translate(m,[0,-0.5,0]);
    m = scale(m,[100,0.1,100]);
    draw(groundCube,m);

    // Buildings
    for(const b of buildings){
      let bm = identity();
      bm = translate(bm,[b.x,b.h/2,b.z]);
      bm = scale(bm,[4,b.h,4]);
      draw(buildingCube,bm);
    }

    // Taxi
    let tm = identity();
    tm = translate(tm,[taxi.x,taxi.y,taxi.z]);
    tm = rotateY(tm,taxi.rotY);
    tm = scale(tm,[1.5,0.6,3]);
    draw(taxiCube,tm);
  }

  let last=0;
  function loop(t){
    const dt = Math.min((t-last)/1000,0.05);
    last=t;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
