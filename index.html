<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Raw WebGL Drift</title>
<style>
  html,body { margin:0; padding:0; overflow:hidden; background:#000; }
  canvas { width:100vw; height:100vh; display:block; }
  #hud {
    position:fixed; top:10px; left:10px; color:white;
    font-family:sans-serif; font-size:14px; text-shadow:0 0 4px black;
  }
</style>
</head>
<body>
<canvas id="gl"></canvas>
<div id="hud">W/S accelerate/brake • A/D steer • Space drift</div>
<script>
// ---------------- INPUT ----------------
const keys = {};
onkeydown = e => keys[e.key.toLowerCase()] = true;
onkeyup   = e => keys[e.key.toLowerCase()] = false;

// ---------------- WEBGL SETUP ----------------
const canvas = document.getElementById("gl");
const gl = canvas.getContext("webgl");
function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  gl.viewport(0,0,canvas.width,canvas.height);
}
resize();
onresize = resize;

// ---------------- SHADERS ----------------
const vs = `
attribute vec3 aPos;
attribute vec3 aCol;
uniform mat4 uMVP;
varying vec3 vCol;
void main(){
  gl_Position = uMVP * vec4(aPos,1.0);
  vCol = aCol;
}`;
const fs = `
precision mediump float;
varying vec3 vCol;
void main(){ gl_FragColor = vec4(vCol,1.0); }`;

function compile(type,src){
  const s = gl.createShader(type);
  gl.shaderSource(s,src);
  gl.compileShader(s);
  return s;
}
const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER,vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);
gl.useProgram(prog);

const aPos = gl.getAttribLocation(prog,"aPos");
const aCol = gl.getAttribLocation(prog,"aCol");
const uMVP = gl.getUniformLocation(prog,"uMVP");

// ---------------- GEOMETRY ----------------
// Ground plane
const ground = [];
const G = 200;
ground.push(
  -G,0,-G, 0.1,0.1,0.1,
   G,0,-G, 0.1,0.1,0.1,
   G,0, G, 0.1,0.1,0.1,
  -G,0,-G, 0.1,0.1,0.1,
   G,0, G, 0.1,0.1,0.1,
  -G,0, G, 0.1,0.1,0.1
);

// Car box
const car = [];
const w=0.7, l=1.3, h=0.4;
function quad(x1,y1,z1, x2,y2,z2, x3,y3,z3, x4,y4,z4, r,g,b){
  car.push(
    x1,y1,z1,r,g,b, x2,y2,z2,r,g,b, x3,y3,z3,r,g,b,
    x1,y1,z1,r,g,b, x3,y3,z3,r,g,b, x4,y4,z4,r,g,b
  );
}
quad(-w,0,-l,  w,0,-l,  w,h,-l, -w,h,-l, 0.8,0.1,0.1);
quad(-w,0, l,  w,0, l,  w,h, l, -w,h, l, 0.8,0.1,0.1);
quad(-w,0,-l, -w,0, l, -w,h, l, -w,h,-l, 0.7,0,0);
quad( w,0,-l,  w,0, l,  w,h, l,  w,h,-l, 0.7,0,0);
quad(-w,h,-l,  w,h,-l,  w,h, l, -w,h, l, 0.9,0.2,0.2);

function makeBuf(arr){
  const b = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,b);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(arr),gl.STATIC_DRAW);
  return b;
}
const groundBuf = makeBuf(ground);
const carBuf = makeBuf(car);

// ---------------- MATRIX UTILS ----------------
function mul(a,b){
  const o=new Float32Array(16);
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      o[i*4+j]=a[i*4+0]*b[j+0]+a[i*4+1]*b[j+4]+a[i*4+2]*b[j+8]+a[i*4+3]*b[j+12];
    }
  }
  return o;
}
function perspective(fov,asp,n,f){
  const t=Math.tan(fov/2);
  return new Float32Array([
    1/(asp*t),0,0,0,
    0,1/t,0,0,
    0,0,(f+n)/(n-f),-1,
    0,0,(2*f*n)/(n-f),0
  ]);
}
function lookAt(ex,ey,ez, cx,cy,cz){
  let zx=ex-cx, zy=ey-cy, zz=ez-cz;
  let rl=1/Math.hypot(zx,zy,zz); zx*=rl; zy*=rl; zz*=rl;
  let xx=0*zz-1*zy, xy=1*zx-0*zz, xz=0*zy-0*zx;
  rl=1/Math.hypot(xx,xy,xz); xx*=rl; xy*=rl; xz*=rl;
  let yx=zy*xz-zz*xx, yy=zz*xy-zx*xz, yz=zx*xx-zy*xy;
  return new Float32Array([
    xx, yx, zx, 0,
    xy, yy, zy, 0,
    xz, yz, zz, 0,
    -(xx*ex+xy*ey+xz*ez),
    -(yx*ex+yy*ey+yz*ez),
    -(zx*ex+zy*ey+zz*ez),
    1
  ]);
}
function rotY(a){
  const c=Math.cos(a), s=Math.sin(a);
  return new Float32Array([
    c,0,s,0,
    0,1,0,0,
   -s,0,c,0,
    0,0,0,1
  ]);
}
function trans(x,y,z){
  return new Float32Array([
    1,0,0,0,
    0,1,0,0,
    0,0,1,0,
    x,y,z,1
  ]);
}

// ---------------- PHYSICS ----------------
let posX=0, posZ=0, yaw=0;
let velX=0, velZ=0;

const maxSpeed=40, accel=25, brake=40;
const grip=4, driftGrip=1.2;
const steer=2.5, friction=3;

let last=performance.now();

function update(dt){
  const fwd = keys["w"]||keys["arrowup"];
  const back= keys["s"]||keys["arrowdown"];
  const left= keys["a"]||keys["arrowleft"];
  const right=keys["d"]||keys["arrowright"];
  const hb = keys[" "];

  const fx=Math.sin(yaw), fz=Math.cos(yaw);
  const vF = velX*fx + velZ*fz;
  const vS = velX*fz - velZ*fx;

  let sp=vF;
  if(fwd) sp+=accel*dt;
  if(back) sp-=brake*dt;
  sp=Math.max(-maxSpeed*0.4, Math.min(maxSpeed,sp));

  let st=0;
  if(left) st+=1;
  if(right) st-=1;
  yaw += st*steer*dt*(sp/maxSpeed);

  const g = hb? driftGrip : grip;
  const newSide = vS*(1-g*dt);

  velX = fx*sp + fz*newSide;
  velZ = fz*sp - fx*newSide;

  velX*=1-friction*dt*0.1;
  velZ*=1-friction*dt*0.1;

  posX+=velX*dt;
  posZ+=velZ*dt;

  if(posX>6){posX=6; velX*=-0.3;}
  if(posX<-6){posX=-6; velX*=-0.3;}

  const L=150;
  if(posZ>L) posZ-=L*2;
  if(posZ<-L) posZ+=L*2;
}

// ---------------- RENDER ----------------
function draw(buf,count,model){
  const asp=canvas.width/canvas.height;
  const P=perspective(Math.PI/3,asp,0.1,500);
  const camDist=6, camH=3;
  const cx=posX - Math.sin(yaw)*camDist;
  const cy=camH;
  const cz=posZ - Math.cos(yaw)*camDist;
  const V=lookAt(cx,cy,cz, posX,0.5,posZ);
  const VP=mul(P,V);
  const MVP=mul(VP,model);

  gl.uniformMatrix4fv(uMVP,false,MVP);
  gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,24,0);
  gl.vertexAttribPointer(aCol,3,gl.FLOAT,false,24,12);
  gl.enableVertexAttribArray(aPos);
  gl.enableVertexAttribArray(aCol);
  gl.drawArrays(gl.TRIANGLES,0,count);
}

function loop(){
  const now=performance.now();
  const dt=Math.min(0.05,(now-last)/1000);
  last=now;

  update(dt);

  gl.enable(gl.DEPTH_TEST);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

  draw(groundBuf, ground.length/6, trans(0,0,0));

  const M = mul(trans(posX,0,posZ), rotY(yaw));
  draw(carBuf, car.length/6, M);

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
