<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Taxi Drift</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
        touch-action: none;
    }
    #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #fff;
        font-family: sans-serif;
        background: rgba(0,0,0,0.4);
        padding: 6px 10px;
        border-radius: 4px;
        z-index: 10;
    }
    #joystick {
        position: absolute;
        left: 20px;
        bottom: 20px;
        width: 150px;
        height: 150px;
        border-radius: 50%;
        border: 2px solid #fff5;
        display: none;
        z-index: 20;
    }
    #thumb {
        width: 60px;
        height: 60px;
        background: #fff5;
        border-radius: 50%;
        position: absolute;
        left: 45px;
        top: 45px;
    }
    #driftBtn {
        position: absolute;
        right: 20px;
        bottom: 40px;
        width: 90px;
        height: 90px;
        border-radius: 50%;
        background: #fff3;
        border: 2px solid #fff7;
        color: white;
        font-size: 20px;
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 20;
    }
</style>
</head>
<body tabindex="0">

<script>
window.onload = () => document.body.focus();
</script>

<div id="info">
    <b>3D Taxi Drift</b><br>
    W/S = accelerate / brake<br>
    A/D = steer<br>
    Space = drift
</div>

<div id="joystick"><div id="thumb"></div></div>
<div id="driftBtn">DRIFT</div>

<!-- ⭐ LOAD THREE.JS FIRST (0.148.0) -->
<script type="module" id="three-loader">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.module.js";
    window.THREE = THREE;
</script>

<!-- ⭐ GAME CODE STARTS AFTER THREE IS LOADED -->
<script>
// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202030);

// Camera
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(40, 80, 20);
scene.add(dir);

// Ground
const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(3000, 3000),
    new THREE.MeshStandardMaterial({ color: 0x222222 })
);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

// Roads
const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
const roadWidth = 20;
const blockSize = 120;

for (let i = -10; i <= 10; i++) {
    const v = new THREE.Mesh(new THREE.PlaneGeometry(roadWidth, 3000), roadMat);
    v.rotation.x = -Math.PI/2;
    v.position.x = i * blockSize;
    scene.add(v);

    const h = new THREE.Mesh(new THREE.PlaneGeometry(3000, roadWidth), roadMat);
    h.rotation.x = -Math.PI/2;
    h.position.z = i * blockSize;
    scene.add(h);
}

// Buildings
const buildingGeo = new THREE.BoxGeometry(40, 80, 40);
const buildingMat = new THREE.MeshStandardMaterial({ color: 0x505070 });

for (let x = -8; x <= 8; x++) {
    for (let z = -8; z <= 8; z++) {
        if (Math.abs(x) < 2 && Math.abs(z) < 2) continue;
        const b = new THREE.Mesh(buildingGeo, buildingMat);
        b.position.set(x * blockSize, 40, z * blockSize);
        scene.add(b);
    }
}

// Taxi
const taxi = new THREE.Group();

const body = new THREE.Mesh(
    new THREE.BoxGeometry(4, 1.2, 8),
    new THREE.MeshStandardMaterial({ color: 0xffd000 })
);
body.position.y = 1;
taxi.add(body);

const roof = new THREE.Mesh(
    new THREE.BoxGeometry(3, 1, 3.5),
    new THREE.MeshStandardMaterial({ color: 0xfff5a0 })
);
roof.position.set(0, 1.8, -0.5);
taxi.add(roof);

const sign = new THREE.Mesh(
    new THREE.BoxGeometry(1.5, 0.4, 0.8),
    new THREE.MeshStandardMaterial({ color: 0x000000 })
);
sign.position.set(0, 2.4, -0.5);
taxi.add(sign);

scene.add(taxi);

// Skid marks
const skidGroup = new THREE.Group();
scene.add(skidGroup);

const skidMat = new THREE.MeshBasicMaterial({
    color: 0x000000,
    transparent: true,
    opacity: 0.5
});
const skidGeo = new THREE.PlaneGeometry(0.4, 1.5);
const skidPool = [];
const maxSkids = 300;

function addSkid(pos, dir) {
    let s;
    if (skidPool.length < maxSkids) {
        s = new THREE.Mesh(skidGeo, skidMat);
        s.rotation.x = -Math.PI/2;
        skidGroup.add(s);
        skidPool.push(s);
    } else {
        s = skidPool.shift();
        skidPool.push(s);
    }
    s.position.copy(pos);
    s.rotation.y = Math.atan2(dir.x, dir.z);
}

// Physics
let speed = 0;
let steering = 0;
let vel = new THREE.Vector3(0,0,0);

const accel = 0.02;
const steerSpeed = 0.03;
const driftFactor = 0.08;
const grip = 0.9;

// Input
const keys = { w:0, s:0, a:0, d:0, space:0 };

document.addEventListener("keydown", e => {
    if (e.code === "KeyW") keys.w = 1;
    if (e.code === "KeyS") keys.s = 1;
    if (e.code === "KeyA") keys.a = 1;
    if (e.code === "KeyD") keys.d = 1;
    if (e.code === "Space") keys.space = 1;
});
document.addEventListener("keyup", e => {
    if (e.code === "KeyW") keys.w = 0;
    if (e.code === "KeyS") keys.s = 0;
    if (e.code === "KeyA") keys.a = 0;
    if (e.code === "KeyD") keys.d = 0;
    if (e.code === "Space") keys.space = 0;
});

// Camera follow
function updateCamera() {
    const offset = new THREE.Vector3(0, 7, 14).applyQuaternion(taxi.quaternion);
    const target = taxi.position.clone().add(offset);
    camera.position.lerp(target, 0.15);
    camera.lookAt(taxi.position.clone().add(new THREE.Vector3(0,2,0)));
}

// Main loop
let last = performance.now();
function animate(now) {
    requestAnimationFrame(animate);
    const dt = (now - last) / 16.67;
    last = now;

    const forwardInput = (keys.w - keys.s);
    const steerInput = (keys.a - keys.d);

    speed += forwardInput * accel * dt;
    speed *= keys.space ? 0.9 : 0.98;

    steering = steerInput * steerSpeed;

    taxi.rotation.y += steering * speed * dt * 2;

    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(taxi.quaternion);
    const right = new THREE.Vector3(1,0,0).applyQuaternion(taxi.quaternion);

    const forwardVel = forward.clone().multiplyScalar(vel.dot(forward));
    let sideVel = right.clone().multiplyScalar(vel.dot(right));

    sideVel.multiplyScalar(grip);
    sideVel.add(right.clone().multiplyScalar(steering * speed * driftFactor));

    vel = forwardVel.add(sideVel);
    vel.add(forward.clone().multiplyScalar(speed * dt * 2));

    taxi.position.add(vel);

    if (Math.abs(vel.dot(right)) > 0.05 && Math.abs(speed) > 0.1) {
        const rearL = taxi.position.clone().add(new THREE.Vector3(-1.2,0.05,2.5).applyQuaternion(taxi.quaternion));
        const rearR = taxi.position.clone().add(new THREE.Vector3(1.2,0.05,2.5).applyQuaternion(taxi.quaternion));
        addSkid(rearL, forward);
        addSkid(rearR, forward);
    }

    updateCamera();
    renderer.render(scene, camera);
}

animate(performance.now());

onresize = () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
};
</script>

</body>
</html>
