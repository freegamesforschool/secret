<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Taxi Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      touch-action: none;
      font-family: sans-serif;
    }
    #joystick-container {
      position: fixed;
      left: 10px;
      bottom: 10px;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: 2px solid #555;
      box-sizing: border-box;
      touch-action: none;
      display: none; /* shown on touch devices */
    }
    #joystick {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 50px;
      height: 50px;
      margin-left: -25px;
      margin-top: -25px;
      border-radius: 50%;
      background: rgba(255,255,255,0.4);
      touch-action: none;
    }
    #drift-btn {
      position: fixed;
      right: 10px;
      bottom: 30px;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: none;
      background: rgba(255, 215, 0, 0.8);
      color: #000;
      font-weight: bold;
      font-size: 16px;
      display: none; /* shown on touch devices */
      touch-action: none;
    }
    #hint {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #fff;
      font-size: 14px;
      background: rgba(0,0,0,0.4);
      padding: 6px 10px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="hint">
    PC: WASD to move, Left Shift to drift<br>
    Mobile: Joystick + Drift button
  </div>
  <div id="joystick-container">
    <div id="joystick"></div>
  </div>
  <button id="drift-btn">DRIFT</button>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // Basic Three.js setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 8, -15);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshPhongMaterial({ color: 0x303030 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Taxi (yellow rectangle)
    const taxiGeo = new THREE.BoxGeometry(2, 1, 4);
    const taxiMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
    const taxi = new THREE.Mesh(taxiGeo, taxiMat);
    taxi.position.y = 0.5;
    scene.add(taxi);

    // Simple "buildings" as big spaced-out rectangles
    const buildingMat = new THREE.MeshPhongMaterial({ color: 0x4444aa });
    const buildingGeo = new THREE.BoxGeometry(6, 10, 6);
    const buildingPositions = [
      [20, 5, 20],
      [-25, 5, 15],
      [30, 5, -10],
      [-15, 5, -25],
      [0, 5, 30],
      [25, 5, -30],
      [-30, 5, 0]
    ];
    buildingPositions.forEach(pos => {
      const b = new THREE.Mesh(buildingGeo, buildingMat);
      b.position.set(pos[0], pos[1], pos[2]);
      scene.add(b);
    });

    // Movement state
    const keys = {};
    let driftKey = false;

    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (e.code === 'ShiftLeft') driftKey = true;
    });
    window.addEventListener('keyup', (e) => {
      keys[e.code] = false;
      if (e.code === 'ShiftLeft') driftKey = false;
    });

    // Mobile detection (very rough)
    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const joystickContainer = document.getElementById('joystick-container');
    const joystick = document.getElementById('joystick');
    const driftBtn = document.getElementById('drift-btn');

    let joyActive = false;
    let joyCenter = { x: 0, y: 0 };
    let joyVector = { x: 0, y: 0 };
    let driftTouch = false;

    if (isTouch) {
      joystickContainer.style.display = 'block';
      driftBtn.style.display = 'block';
    }

    function handleJoyStart(e) {
      e.preventDefault();
      joyActive = true;
      const rect = joystickContainer.getBoundingClientRect();
      joyCenter.x = rect.left + rect.width / 2;
      joyCenter.y = rect.top + rect.height / 2;
    }

    function handleJoyMove(e) {
      if (!joyActive) return;
      e.preventDefault();
      const touch = e.touches ? e.touches[0] : e;
      const dx = touch.clientX - joyCenter.x;
      const dy = touch.clientY - joyCenter.y;
      const maxDist = 40;
      const dist = Math.min(Math.sqrt(dx * dx + dy * dy), maxDist);
      const angle = Math.atan2(dy, dx);
      const x = Math.cos(angle) * dist;
      const y = Math.sin(angle) * dist;
      joystick.style.transform = `translate(${x}px, ${y}px)`;
      joyVector.x = x / maxDist;
      joyVector.y = y / maxDist;
    }

    function handleJoyEnd(e) {
      e && e.preventDefault();
      joyActive = false;
      joyVector.x = 0;
      joyVector.y = 0;
      joystick.style.transform = 'translate(0px, 0px)';
    }

    joystickContainer.addEventListener('touchstart', handleJoyStart);
    joystickContainer.addEventListener('touchmove', handleJoyMove);
    joystickContainer.addEventListener('touchend', handleJoyEnd);
    joystickContainer.addEventListener('touchcancel', handleJoyEnd);

    driftBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      driftTouch = true;
    });
    driftBtn.addEventListener('touchend', (e) => {
      e.preventDefault();
      driftTouch = false;
    });

    // Movement parameters
    let velocity = 0;
    let angle = 0;
    const accel = 0.08;
    const maxSpeed = 0.8;
    const friction = 0.04;
    const turnSpeed = 0.04;
    const driftTurnMultiplier = 2.2;
    const driftFrictionMultiplier = 0.3;

    function updateMovement() {
      let forward = 0;
      let turn = 0;
      let drifting = driftKey || driftTouch;

      if (!isTouch) {
        // PC controls: WASD
        if (keys['KeyW']) forward += 1;
        if (keys['KeyS']) forward -= 1;
        if (keys['KeyA']) turn += 1;
        if (keys['KeyD']) turn -= 1;
      } else {
        // Mobile: joystick
        forward = -joyVector.y; // up on screen is negative y
        turn = joyVector.x;
      }

      // Acceleration
      if (forward !== 0) {
        velocity += forward * accel;
        if (velocity > maxSpeed) velocity = maxSpeed;
        if (velocity < -maxSpeed * 0.6) velocity = -maxSpeed * 0.6;
      } else {
        // friction
        const fr = drifting ? friction * driftFrictionMultiplier : friction;
        if (velocity > 0) {
          velocity = Math.max(0, velocity - fr);
        } else if (velocity < 0) {
          velocity = Math.min(0, velocity + fr);
        }
      }

      // Turning
      if (Math.abs(velocity) > 0.01 && turn !== 0) {
        const turnMul = drifting ? driftTurnMultiplier : 1;
        angle += turn * turnSpeed * turnMul * (velocity >= 0 ? 1 : -1);
      }

      // Apply movement
      taxi.rotation.y = angle;
      const dx = Math.sin(angle) * velocity;
      const dz = Math.cos(angle) * velocity;
      taxi.position.x += dx;
      taxi.position.z += dz;
    }

    function updateCamera() {
      const camDist = 12;
      const camHeight = 6;
      const offsetX = Math.sin(angle) * -camDist;
      const offsetZ = Math.cos(angle) * -camDist;
      camera.position.set(
        taxi.position.x + offsetX,
        taxi.position.y + camHeight,
        taxi.position.z + offsetZ
      );
      camera.lookAt(taxi.position.x, taxi.position.y + 1, taxi.position.z);
    }

    function animate() {
      requestAnimationFrame(animate);
      updateMovement();
      updateCamera();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
